<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe</title>
  
  <subtitle>Joe</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aidevjoe.github.io/"/>
  <updated>2019-03-22T03:07:35.281Z</updated>
  <id>http://aidevjoe.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将 SVN 仓库转换成 Git 仓库</title>
    <link href="http://aidevjoe.github.io/2019/03/22/%E5%B0%86%20SVN%20%E4%BB%93%E5%BA%93%E8%BD%AC%E6%8D%A2%E6%88%90%20Git%20%E4%BB%93%E5%BA%93/"/>
    <id>http://aidevjoe.github.io/2019/03/22/将 SVN 仓库转换成 Git 仓库/</id>
    <published>2019-03-22T03:02:32.000Z</published>
    <updated>2019-03-22T03:07:35.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于习惯了 Git 代码版本控制工具的便利，最近接手公司老项目都是使用 SVN，缺点就不说了，实在受不了这种古董级到代码版本控制工具。所以今天抽了时间，将 SVN 转换到 Git 仓库，以下记录操作记录。</p><h2 id="一、-获取原-SVN-仓库使用的用户名字列表"><a href="#一、-获取原-SVN-仓库使用的用户名字列表" class="headerlink" title="一、 获取原 SVN 仓库使用的用户名字列表"></a>一、 获取原 SVN 仓库使用的用户名字列表</h2><p>SVN 中，每个用户提交时都需要在系统中有一个用户，用于记录在提交信息中。但是这些用户仅有用户名，与 Git 的默认格式有些差异，所以需要先获取原仓库的用户信息，然后修改成符合 Git 格式这些信息的格式和内容与 Git 默认的格式和内容略有差别，所以我们需要去获得原 SVN 仓库使用的用户名字列表信息并做格式改动。</p><p>进入到 SVN 项目工作目录中，执行以下命令获取原用户列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn <span class="built_in">log</span> -q | awk -F <span class="string">'|'</span> <span class="string">'/^r/ &#123;sub("^ ", "", $2); sub(" $", "", $2); print $2" = "$2" &lt;"$2"&gt;"&#125;'</span> | sort -u &gt; users.txt</span><br></pre></td></tr></table></figure><p>执行完改命令，会在当前目录生成 <code>users.text</code> 文件，格式看起来像下面这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Joe = Joe &lt;Joe&gt;</span><br><span class="line">Lisen = Lisen &lt;Lisen&gt;</span><br><span class="line">Zl = Zl &lt;Zl&gt;</span><br></pre></td></tr></table></figure><p>我们需要将它修改成 Git 的格式，为每个用户添加 Email</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Joe = Joe &lt;aidevjoe@example.com&gt;</span><br><span class="line">Lisen = Lisen &lt;Lisen@example.com&gt;</span><br><span class="line">Zl = Zl &lt;Zl@example.com&gt;</span><br></pre></td></tr></table></figure><h2 id="二、-生成-Git-仓库"><a href="#二、-生成-Git-仓库" class="headerlink" title="二、 生成 Git 仓库"></a>二、 生成 Git 仓库</h2><p>利用 Git 内置的 <code>git svn</code> 命令克隆 SVN 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn <span class="built_in">clone</span> --stdlayout --no-metadata -A user.txt https://192.168.1.50/svn/Repo/ RepoDir</span><br></pre></td></tr></table></figure><blockquote><p><code>--stdlayout</code>: 示你的项目在 SVN 中是常见的 “trunk/branches/tags” 目录结构，如果不是，那你需要使用 –tags, –branches, –trunk 参数（请通过 git svn help 自行了解）。<br><code>--no-metadata</code>: 让原 SVN 项目日志中的内容更符合 Git 的格式规范，且去掉了 SVN ID、URL 此类无用信息。<br><code>-A user.txt</code>: <code>-A</code> 为指定用户列表信息。<code>user.txt</code> 为用户列表信息的文件。如果 <code>user.txt</code> 不当前目录，可以改为具体路径，例如 <code>-A /Users/joe/Desktop/user.txt</code> 。<br><code>https://192.168.1.50/svn/Repo/</code>: 表示 SVN 的仓库服务器地址。<br><code>RepoDir</code>: 为目标目录，这将会在 RepoDir 新建一个 Git repo，并开始从 SVN 中拉取代码。</p></blockquote><p>如果遇到以下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Author: VisualSVN Server not defined in userinfo.txt file</span><br></pre></td></tr></table></figure><p>在 <code>user.txt</code> 文件里添加以下内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VisualSVN Server = Visual SVN Server &lt;admin@yourdomain.com&gt;</span><br></pre></td></tr></table></figure><p>如果原仓库比较大，时间可能需要一定时间，等待获取完，生成好的 Git 仓库将放在您指定的目录中。</p><p>如果需要获取其他分支，可以参考下面的链接.</p><p>Done.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://www.lovelucy.info/codebase-from-svn-to-git-migration-keep-commit-history.html" target="_blank" rel="noopener">将代码库从 SVN 迁移至 Git 并保留所有 commit 记录</a><br>2、<a href="https://coding.net/help/doc/git/import-from-svn.html" target="_blank" rel="noopener">如何将 SVN 仓库代码导入 CODING</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于习惯了 Git 代码版本控制工具的便利，最近接手公司老项目都是使用 SVN，缺点就不说了，实在受不了这种古董级到代码版本控制工具。所以今
      
    
    </summary>
    
      <category term="Git" scheme="http://aidevjoe.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://aidevjoe.github.io/tags/Git/"/>
    
      <category term="SVN" scheme="http://aidevjoe.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>使用 expect 自动化部署项目</title>
    <link href="http://aidevjoe.github.io/2019/03/19/%E4%BD%BF%E7%94%A8-expect-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <id>http://aidevjoe.github.io/2019/03/19/使用-expect-自动化部署项目/</id>
    <published>2019-03-19T14:02:32.000Z</published>
    <updated>2019-03-22T03:36:26.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司需要接手几个 .Net Core 后台项目，由于之前从来没有接触过 C# 和 .Net 开发，花了一些时间了解。后台开发的思维很多都是互通的，之前也有 PHP 和少许 Java 后台开发的经验，所以上手不需要太久，主要是业务逻辑这块需要花些功夫。但是每次部署到服务器时感觉不是很方便，每次都需要通过 dotnet publish 命令发布项目到本地，然后将发布的项目文件通过 ftp 上传到服务器，再 ssh 到服务器，将 supervisorctl 项目重启。虽然都很简单，但是每次部署都需要重复的操作，也很麻烦。程序员都是懒惰的，所用想着用将这些操作弄成自动化写到脚本，执行脚本就完成部署。最后了解到 expect 神器，通过 expect 可以将上面操作通过一个脚步完成。</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开发环境: macOS</span><br><span class="line">代码编辑器: VSCode</span><br><span class="line">服务器: CentOS</span><br><span class="line">Web 服务器: nginx</span><br><span class="line">进程管理工具: supervisor</span><br></pre></td></tr></table></figure><h2 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h2><p>expect 是一个控制自动交互式脚本的工具，用非交互的方式实现了所有交互式的功能。相关文档可以参考 <a href="http://xstarcd.github.io/wiki/shell/expect.html" target="_blank" rel="noopener">http://xstarcd.github.io/wiki/shell/expect.html</a></p><p>通过 <code>shell</code> 和 <code>expect</code> 写了一个自动化部署到脚本。以下为全部代码，部署分本地部署和线上部署，通过参数传递。</p><p>整个代码主要分两块：<br>1、通过 <code>sftp</code> 上传编译之后的文件到服务器<br>2、通过 <code>ssh</code> 连接到服务器，然后重启 <code>supervisor</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author by Joe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FTP 相关配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线上服务器</span></span><br><span class="line">PRODUCT_HOST=<span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">PRODUCT_PWD=<span class="string">"pwd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地服务器</span></span><br><span class="line">LOCAL_HOST=<span class="string">"192.168.50.1"</span></span><br><span class="line">LOCAL_PWD=<span class="string">"123"</span></span><br><span class="line"></span><br><span class="line">USER=<span class="string">"root"</span> <span class="comment">#FTP用户名</span></span><br><span class="line">HOST=<span class="string">""</span>     <span class="comment">#FTP服务器地址</span></span><br><span class="line">PASSWD=<span class="string">""</span>   <span class="comment">#FTP用户密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> != 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"USAGE: Publish to production server or local server"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" e.g.: <span class="variable">$0</span> product or <span class="variable">$0</span> local"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">ENV=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$ENV</span> == <span class="string">"local"</span> ]; <span class="keyword">then</span></span><br><span class="line">    HOST=<span class="variable">$&#123;LOCAL_HOST&#125;</span></span><br><span class="line">    PASSWD=<span class="variable">$&#123;LOCAL_PWD&#125;</span></span><br><span class="line">    ENV=<span class="string">"Debug"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$ENV</span> == <span class="string">'product'</span> ]; <span class="keyword">then</span></span><br><span class="line">    HOST=<span class="variable">$&#123;PRODUCT_HOST&#125;</span></span><br><span class="line">    PASSWD=<span class="variable">$&#123;PRODUCT_PWD&#125;</span></span><br><span class="line">    ENV=<span class="string">"Product"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数必须为 local 或者 product"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> timeout 30</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[47;30mINFO: 准备发布到 <span class="variable">$ENV</span> 服务器...\033[0m"</span></span><br><span class="line">DEST_DIR=<span class="string">"/root"</span>                                                     <span class="comment">#远程FTP服务器目录</span></span><br><span class="line">SHELL_FOLDER=$(<span class="built_in">pwd</span>)                                                  <span class="comment"># 当前目录</span></span><br><span class="line">LOC_DIR=<span class="string">"<span class="variable">$&#123;SHELL_FOLDER&#125;</span>/Servers/bin/<span class="variable">$&#123;ENV&#125;</span>/netcoreapp2.1/Game"</span> <span class="comment">#对应的本地服务器目录</span></span><br><span class="line">DIR_NAME=<span class="string">"Game"</span>                                                     <span class="comment"># 线上服务器项目文件夹名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo $HOST</span></span><br><span class="line"><span class="comment"># echo $PASSWD</span></span><br><span class="line"><span class="comment"># echo $LOC_DIR</span></span><br><span class="line"><span class="comment"># exit 1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[47;30mINFO: 正在登录 SFTP 服务器...\033[0m"</span></span><br><span class="line"></span><br><span class="line">expect &lt;&lt;-END</span><br><span class="line"></span><br><span class="line">spawn sftp <span class="variable">$USER</span>@<span class="variable">$HOST</span></span><br><span class="line">expect &#123;</span><br><span class="line">    <span class="string">"(yes/no)?"</span> &#123;</span><br><span class="line">        send <span class="string">"yes\r"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"*assword:"</span> &#123;send <span class="string">"<span class="variable">$&#123;PASSWD&#125;</span>\r"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"cd <span class="variable">$&#123;DEST_DIR&#125;</span>\r"</span></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"ls\r"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧版本</span></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"rm <span class="variable">$&#123;DIR_NAME&#125;</span>/Config/*\r"</span></span><br><span class="line"></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"rmdir <span class="variable">$&#123;DIR_NAME&#125;</span>/Config\r"</span></span><br><span class="line"></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"rm <span class="variable">$&#123;DIR_NAME&#125;</span>/*\r"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"rmdir <span class="variable">$&#123;DIR_NAME&#125;</span>\r"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件到服务器</span></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"put -r <span class="variable">$&#123;LOC_DIR&#125;</span>\r"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名为目标文件夹名</span></span><br><span class="line"><span class="comment"># expect "sftp&gt;"</span></span><br><span class="line"><span class="comment"># send "rename publish $&#123;DIR_NAME&#125;\r"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">expect <span class="string">"sftp&gt;"</span></span><br><span class="line">send <span class="string">"quit\r"</span></span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">PWD=<span class="variable">$&#123;PASSWD&#125;</span></span><br><span class="line">SupervisorName=YGame</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[47;30mINFO: 正在登录远程服务器，准备重启 supervisor..\033[0m"</span></span><br><span class="line"></span><br><span class="line">expect &lt;&lt;-END</span><br><span class="line"></span><br><span class="line">spawn ssh root@<span class="variable">$&#123;HOST&#125;</span></span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">    <span class="string">"yes/no"</span> &#123; send <span class="string">"yes\r"</span>; exp_continue&#125;</span><br><span class="line">    <span class="string">"password:"</span> &#123; send <span class="string">"<span class="variable">$&#123;PWD&#125;</span>\r"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect <span class="string">"]# "</span></span><br><span class="line"></span><br><span class="line">send <span class="string">"pwd\r"</span></span><br><span class="line"></span><br><span class="line">send <span class="string">"supervisorctl status\r"</span></span><br><span class="line">send <span class="string">"supervisorctl restart <span class="variable">$&#123;SupervisorName&#125;</span>\r"</span></span><br><span class="line">send <span class="string">"tail -n 15 <span class="variable">$&#123;DEST_DIR&#125;</span>/<span class="variable">$&#123;DIR_NAME&#125;</span>/Server.log\r"</span></span><br><span class="line">send <span class="string">"exit\r"</span></span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\033[47;30mINFO: 操作完成 !!! .\033[0m"</span></span><br></pre></td></tr></table></figure><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>通过 VSCode 写两个 <code>task</code>，任务一负责编译并将文件发布到本地，任务二则是调用该脚本，下次编辑完直接调用 VSCode task 即可，以下为 VSCode Task 配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"publish YGame Product"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"dotnet"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"process"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"msbuild"</span>,</span><br><span class="line">        <span class="string">"$&#123;workspaceFolder&#125;/YGameServer/YGameServer.csproj"</span>,</span><br><span class="line">        <span class="string">"/p:Configuration=Product"</span>,</span><br><span class="line">        <span class="string">"/p:DeployOnBuild=true"</span>,</span><br><span class="line">        <span class="string">"/p:PublishProfile=$&#123;workspaceFolder&#125;/YGameServer/Properties/PublishProfiles/Product.pubxml"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: <span class="string">"$msCompile"</span>,</span><br><span class="line">      <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">        <span class="attr">"echo"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">        <span class="attr">"focus"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"panel"</span>: <span class="string">"shared"</span>,</span><br><span class="line">        <span class="attr">"showReuseMessage"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"publish YGame Debug"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"dotnet"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"process"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"msbuild"</span>,</span><br><span class="line">        <span class="string">"$&#123;workspaceFolder&#125;/YGameServer/YGameServer.csproj"</span>,</span><br><span class="line">        <span class="string">"/p:Configuration=Debug"</span>,</span><br><span class="line">        <span class="string">"/p:DeployOnBuild=true"</span>,</span><br><span class="line">        <span class="string">"/p:PublishProfile=$&#123;workspaceFolder&#125;/YGameServer/Properties/PublishProfiles/Debug.pubxml"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"problemMatcher"</span>: <span class="string">"$msCompile"</span>,</span><br><span class="line">      <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">        <span class="attr">"echo"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">        <span class="attr">"focus"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"panel"</span>: <span class="string">"shared"</span>,</span><br><span class="line">        <span class="attr">"showReuseMessage"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"deploy YGame to Remote Server"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"$&#123;workspaceFolder&#125;/deploy.sh"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [<span class="string">"product"</span>],</span><br><span class="line">      <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">        <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">        <span class="attr">"panel"</span>: <span class="string">"new"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"dependsOn"</span>: [<span class="string">"publish YGame Product"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"deploy YGame to Local Test Server"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"$&#123;workspaceFolder&#125;/deploy.sh"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [<span class="string">"local"</span>],</span><br><span class="line">      <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">        <span class="attr">"reveal"</span>: <span class="string">"always"</span>,</span><br><span class="line">        <span class="attr">"panel"</span>: <span class="string">"new"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"dependsOn"</span>: [<span class="string">"publish YGame Debug"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近公司需要接手几个 .Net Core 后台项目，由于之前从来没有接触过 C# 和 .Net 开发，花了一些时间了解。后台开发的思维很多都
      
    
    </summary>
    
      <category term="自动化" scheme="http://aidevjoe.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="expect，.net" scheme="http://aidevjoe.github.io/tags/expect%EF%BC%8C-net/"/>
    
  </entry>
  
  <entry>
    <title>升级 macOS 自带 bash 到最新版本</title>
    <link href="http://aidevjoe.github.io/2019/03/01/%E5%8D%87%E7%BA%A7macOS%E8%87%AA%E5%B8%A6bash/"/>
    <id>http://aidevjoe.github.io/2019/03/01/升级macOS自带bash/</id>
    <published>2019-03-01T05:30:44.000Z</published>
    <updated>2019-03-01T05:45:10.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先查看当前-bash-版本"><a href="#首先查看当前-bash-版本" class="headerlink" title="首先查看当前 bash 版本"></a>首先查看当前 bash 版本</h3><p>使用 <code>bash -version</code> 命令查看当前 bash 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash -version</span><br><span class="line">GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin18)</span><br><span class="line">Copyright (C) 2007 Free Software Foundation, Inc.</span><br></pre></td></tr></table></figure><h3 id="通过-homebrew-安装最新版-bash"><a href="#通过-homebrew-安装最新版-bash" class="headerlink" title="通过 homebrew 安装最新版 bash"></a>通过 homebrew 安装最新版 bash</h3><p>一、如果没有安装 homebrew，执行以下命令安装 homebrew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>二、安装 bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install bash</span><br></pre></td></tr></table></figure><p>三、替换系统自带 bash，并做备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv /bin/bash /bin/bash.origin</span><br><span class="line">$ sudo ln -s /usr/local/opt/bash/bin/bash /bin/bash</span><br></pre></td></tr></table></figure><p>四、由于 macOS 下的 sh 并不是直接链接 bash，而是 bash 的一个文件拷贝。所以还要替换默认的 sh 指向的命令为 bash，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv /bin/sh /bin/sh.origin</span><br><span class="line">$ sudo ln -s /usr/local/opt/bash/bin/bash /bin/sh</span><br></pre></td></tr></table></figure><h3 id="最后验证是否安装成功"><a href="#最后验证是否安装成功" class="headerlink" title="最后验证是否安装成功"></a>最后验证是否安装成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ bash -version</span><br><span class="line">GNU bash，版本 5.0.2(1)-release (x86_64-apple-darwin18.2.0)</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">许可证 GPLv3+: GNU GPL 许可证第三版或者更新版本 &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line"></span><br><span class="line">本软件是自由软件，您可以自由地更改和重新发布。</span><br><span class="line">在法律许可的情况下特此明示，本软件不提供任何担保。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;首先查看当前-bash-版本&quot;&gt;&lt;a href=&quot;#首先查看当前-bash-版本&quot; class=&quot;headerlink&quot; title=&quot;首先查看当前 bash 版本&quot;&gt;&lt;/a&gt;首先查看当前 bash 版本&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;bash -version
      
    
    </summary>
    
      <category term="macOS" scheme="http://aidevjoe.github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://aidevjoe.github.io/tags/macOS/"/>
    
      <category term="bash" scheme="http://aidevjoe.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>如何提升 App 用户体验的一些细节</title>
    <link href="http://aidevjoe.github.io/2018/11/26/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87-App-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <id>http://aidevjoe.github.io/2018/11/26/如何提升-App-用户体验的一些细节/</id>
    <published>2018-11-26T06:33:28.000Z</published>
    <updated>2018-11-26T06:57:57.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个细节控，完美主义者。</p><p>在使用某款 App 时。经常会遇到一些糟糕的设计和用户体验，影响使用产品时的心情和操作体验，从而流失用户，这其中不乏一些大厂的 App。</p><p>那么如何避免这些问题，尽可能的提升用户体验，以下是本人自身总结出来的一些通用的提升用户体验的小细节，当然任何细节设计都需要结合产品本身，从而打造一款完美的产品。</p><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><ul><li>搜索框自动聚焦</li></ul><p>当进入某一个搜索页面，或者默认的选项比较多，此时再让用户点击一次搜索框，无疑再增加一次用户的操作成本</p><ul><li>键盘类型</li></ul><p>例如输入框接收的是 <strong>邮箱</strong>，将键盘类型设置为 <code>UIKeyboardTypeNamePhonePad</code>，如果是 <strong>数字</strong> 则设置为 <code>UIKeyboardTypePhonePad</code>，省去用户再次切换输入法的过程</p><ul><li>键盘遮挡</li></ul><p>当用户点击 <strong>输入框</strong> 弹出键盘时，避免键盘遮挡住显示的信息。</p><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><ul><li>上拉或下拉刷新时显示 HUD</li></ul><p>在进行网络请求时，发现很多 App 在显示上拉或下拉刷新动画时，同时还在屏幕中间显示一个 <strong>加载动画</strong>，如此会显示多此一举，用户也无法在过程中做其他操作</p><ul><li>显示 HUD 时，无法返回</li></ul><p>在进入某个页面，需要请求网络时，很多开发者喜欢直接显示一个全屏的 <strong>加载动画</strong>。<br>如果网络请求时间过长，连导航栏的 <strong>返回</strong> 也无法点击，用户只能杀掉 App，重新打开。</p><ul><li>网络状态变化提示</li></ul><p>当用户从 <strong>Wi-Fi</strong> 状态，变成手机网络，做一些耗流量的操作时（如视频、大图），提示用户网络状态变化。</p><ul><li>进度条</li></ul><p>若你的软件需要长时间的加载请求，例如下载数据包，此时可以考虑用进度条来实时显示加载进度，而不是一味的显示 <strong>转圈</strong> 动画。有了进度条，再有等待也不会比无限地等待长。因此，你应该清晰地让用户知道他们需要等待多久。</p><h3 id="内容排版"><a href="#内容排版" class="headerlink" title="内容排版"></a>内容排版</h3><ul><li>英语单词之间的间隔</li></ul><p>很多时候现实的信息中夹杂着英语单词，如果能再单词两边加上一个空格，能更好的提升阅读体验</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>生硬的视图转场</li></ul><p>经常看到一些 App，在需要用户选择 生日、地址 时，直接 显示/隐藏 视图，没有任何过渡动画，会显得非常生硬，影响用户的视觉体验</p><ul><li>占位图显示</li></ul><p>在某个页面没有数据或网络请求失败时，用占位图来告知用户，而不是一片空白没有任何内容</p><ul><li>iPhone X 类设备视频</li></ul><p><code>iOS 11</code> 之后新增了一个 <code>安全区域</code> 的概念，页面上需要显示一个 <code>UITableView</code>，很多开发者直接将视图对其安全区域，在类 <code>iPhone X</code> 设备上，底部会有 <strong>34</strong> 的空白区域</p><ul><li>调节音量时的视图遮挡</li></ul><p>例如在观看视频时，用户通过设备的调节音量键来调节音量，此时会显示系统默认的HUD，而导致视频内容被遮挡。</p><ul><li>按钮不可点击状态</li></ul><p>例如用户在一个登录，还为输入账号和密码时，让登录按钮置灰不可点击状态，而不是点击之后显示 “请输入账号和密码”</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>私密信息遮挡</li></ul><p>例如 <strong>银行 App</strong> 一些安全性或隐私性比较高的软件，在用户切换应用时，做模糊处理，避免隐私的泄露</p><ul><li>App 状态恢复</li></ul><p>例如一个工具类的应用，当 App 被系统杀掉进程后，用户下次打开 App 时，自动恢复到最后浏览位置</p><ul><li>恢复系统音频</li></ul><p>例如当用户正在后台播放音乐，用户在应用中触发了某个视频，占用了系统音频资源，当播放完毕后，用户后台的音乐无法再继续播放，需要用户再次回到音乐播放软件中播放音乐。所以在需要临时调用系统音频播放声音时，及时的释放并恢复之前的状态。</p><ul><li>敏感操作二次确认提示</li></ul><p>例如用户在删除数据，删除好友等进行一些敏感操作时，提示二次确认的按钮，避免用户误操作。</p><ul><li>提供用户反馈入口</li></ul><p>收集用户的意见和建议，筛选合理的请求来完善产品</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>一款好的应用，除了产品本身的价值外，美观合理的界面设计、良好的用户体验及微小的细节往往能更打动用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个细节控，完美主义者。&lt;/p&gt;
&lt;p&gt;在使用某款 App 时。经常会遇到一些糟糕的设计和用户体验，影响使用产品时的心情和操作体验，从而
      
    
    </summary>
    
    
      <category term="iOS，产品" scheme="http://aidevjoe.github.io/tags/iOS%EF%BC%8C%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>利用 Apple Configurator 2 获取 iOS 设备上App的ipa文件.md</title>
    <link href="http://aidevjoe.github.io/2018/11/25/%E5%88%A9%E7%94%A8-Apple-Configurator-2-%E8%8E%B7%E5%8F%96-iOS-%E8%AE%BE%E5%A4%87%E4%B8%8AApp%E7%9A%84ipa%E6%96%87%E4%BB%B6-md/"/>
    <id>http://aidevjoe.github.io/2018/11/25/利用-Apple-Configurator-2-获取-iOS-设备上App的ipa文件-md/</id>
    <published>2018-11-25T06:17:46.000Z</published>
    <updated>2018-11-26T06:59:21.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用-Apple-Configurator-获取-App-的-ipa文件"><a href="#利用-Apple-Configurator-获取-App-的-ipa文件" class="headerlink" title="利用 Apple Configurator 获取 App 的 ipa文件"></a>利用 Apple Configurator 获取 App 的 ipa文件</h1><blockquote><p>由于最新版 iTunes 无法继续下载应用，本文利用 Apple Configurator 获取 ipa文件</p></blockquote><h3 id="一、安装-Apple-Configurator-2"><a href="#一、安装-Apple-Configurator-2" class="headerlink" title="一、安装 Apple Configurator 2"></a>一、安装 Apple Configurator 2</h3><p>下载 Mac App Store 中 搜索并安装 <a href="https://itunes.apple.com/cn/app/apple-configurator-2/id1037126344?mt=12" target="_blank" rel="noopener">Apple Configurator 2</a></p><h3 id="二、将-iPhone-连接到-Mac，并登录-iCloud-账号"><a href="#二、将-iPhone-连接到-Mac，并登录-iCloud-账号" class="headerlink" title="二、将 iPhone 连接到 Mac，并登录 iCloud 账号"></a>二、将 iPhone 连接到 Mac，并登录 iCloud 账号</h3><h5 id="1、-点击菜单栏的-账号-gt-登录"><a href="#1、-点击菜单栏的-账号-gt-登录" class="headerlink" title="1、 点击菜单栏的 账号-&gt;登录"></a>1、 点击菜单栏的 <code>账号-&gt;登录</code></h5><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxk8zxqldcj20kw0h9ab8.jpg" alt=""></p><h5 id="2、-将-iPhone-连接到-Mac"><a href="#2、-将-iPhone-连接到-Mac" class="headerlink" title="2、 将 iPhone 连接到 Mac"></a>2、 将 iPhone 连接到 Mac</h5><h3 id="三、获取-ipa-文件"><a href="#三、获取-ipa-文件" class="headerlink" title="三、获取 ipa 文件"></a>三、获取 <code>ipa</code> 文件</h3><h5 id="1、-点击工具栏的-添加-gt-应用"><a href="#1、-点击工具栏的-添加-gt-应用" class="headerlink" title="1、 点击工具栏的 添加-&gt;应用"></a>1、 点击工具栏的 <code>添加-&gt;应用</code></h5><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxk9j4lcunj20rq0jxten.jpg" alt=""></p><h5 id="2、-搜索需要下载的应用"><a href="#2、-搜索需要下载的应用" class="headerlink" title="2、 搜索需要下载的应用"></a>2、 搜索需要下载的应用</h5><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxk9lf0wayj20rp0jxjvj.jpg" alt=""></p><h5 id="3、-下载应用"><a href="#3、-下载应用" class="headerlink" title="3、 下载应用"></a>3、 下载应用</h5><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxk9mkm66uj20rr0jwdkh.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxk9r6ujh7j20rp0jwte5.jpg" alt=""></p><h5 id="4、获取-ipa-文件"><a href="#4、获取-ipa-文件" class="headerlink" title="4、获取 ipa 文件"></a>4、获取 <strong>ipa</strong> 文件</h5><p>右键单击 <strong>Dock栏</strong> 中的 <code>Finder-&gt;前往文件夹</code>，并输入以下路径</p><p><code>~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</code></p><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxk9uwj57bj20xy0dln1h.jpg" alt=""></p><p>进入 ipa 所在路径，并将 ipa文件拷贝至任意位置</p><p>回到 Apple Configurator 2 窗口中，并点击 <code>停止</code>，此时刚才目录下的文件也会消失</p><p>拿到 <code>ipa</code> 文件就可以做你想的事情了。</p><p>Enjoy 😊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用-Apple-Configurator-获取-App-的-ipa文件&quot;&gt;&lt;a href=&quot;#利用-Apple-Configurator-获取-App-的-ipa文件&quot; class=&quot;headerlink&quot; title=&quot;利用 Apple Configurato
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://aidevjoe.github.io/tags/iOS/"/>
    
      <category term="macOS" scheme="http://aidevjoe.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 和 Supervisor 部署 Vapor 应用程序</title>
    <link href="http://aidevjoe.github.io/2018/07/11/%E4%BD%BF%E7%94%A8-Nginx-%E5%92%8C-Supervisor-%E9%83%A8%E7%BD%B2-Vapor-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://aidevjoe.github.io/2018/07/11/使用-Nginx-和-Supervisor-部署-Vapor-应用程序/</id>
    <published>2018-07-11T09:03:35.000Z</published>
    <updated>2018-11-26T07:07:31.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vapor 是基于 Swift 实现的 Web 框架与服务,可运行于 macOS 和 Ubuntu 系统上，本文主要记录如何使用 Nginx 和 Supervisor 部署 Vapor 应用程序</p></blockquote><h2 id="一、安装-Vapor、Swift"><a href="#一、安装-Vapor、Swift" class="headerlink" title="一、安装 Vapor、Swift"></a>一、安装 Vapor、Swift</h2><h4 id="添加-API-Repo"><a href="#添加-API-Repo" class="headerlink" title="添加 API Repo"></a>添加 API Repo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval &quot;$(curl -sL https://apt.vapor.sh)&quot;</span><br></pre></td></tr></table></figure><h4 id="安装-Vapor"><a href="#安装-Vapor" class="headerlink" title="安装 Vapor"></a>安装 Vapor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install swift vapor</span><br></pre></td></tr></table></figure><h4 id="验证安装结果"><a href="#验证安装结果" class="headerlink" title="验证安装结果"></a>验证安装结果</h4><p>输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swift --version</span><br></pre></td></tr></table></figure><p>您应该会看到类似下面的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Swift version 4.1 (swift-4.1-RELEASE)</span><br><span class="line">Target: x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure><h2 id="二、创建一个最基本的-Vapor-项目"><a href="#二、创建一个最基本的-Vapor-项目" class="headerlink" title="二、创建一个最基本的 Vapor 项目"></a>二、创建一个最基本的 Vapor 项目</h2><p>使用以下命令创建一个默认基于 API 模版的项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vapor new Hello</span><br></pre></td></tr></table></figure><p>等待创建完成，进入该目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd Hello</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vapor build</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vapor run serve</span><br></pre></td></tr></table></figure><p>如无意外，访问 <strong><a href="http://localhost/hello" target="_blank" rel="noopener">http://localhost/hello</a></strong> 将会显示 “hello world”.</p><h2 id="三、安装并设置-Nginx"><a href="#三、安装并设置-Nginx" class="headerlink" title="三、安装并设置 Nginx"></a>三、安装并设置 Nginx</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>通过运行以下命令安装 Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update </span><br><span class="line">$ sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p>通过从浏览器向服务器的域名或 IP 发送GET请求来检查 nginx是否设置正确。如果您看到下面的欢迎页面，则表示您已成功设置Nginx。</p><p><img src="http://joe.nihomecat.com/18-7-11/82908135.jpg" alt=""></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>修改 Nginx 配置信息以将请求转发到 Vapor 来处理</p><p>更改默认的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/nignx/sites-available/default</span><br></pre></td></tr></table></figure><p>修改成下面这样。</p><blockquote><p>在开始前，建议您将默认配置文件备份一份，以防止错误。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80 default_server;</span><br><span class="line">listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">root /home/ubuntu/v2erBackend/Public/; </span><br><span class="line"></span><br><span class="line">try_files $uri @proxy;</span><br><span class="line"></span><br><span class="line">location @proxy &#123;</span><br><span class="line">proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    proxy_pass_header Server;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_pass_header Server;</span><br><span class="line">    proxy_connect_timeout 3s;</span><br><span class="line">    proxy_read_timeout 10s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行 Nginx 服务器，测试是否转发成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service nginx restart</span><br><span class="line">$ cd /home/ubuntu/Hello   # 创建的 Vapor 项目路径</span><br><span class="line">$ vapor build</span><br><span class="line">$ vapor run serve</span><br></pre></td></tr></table></figure><p>通过浏览器访问 <strong><a href="http://YourDomainOrIPAddress/hello" target="_blank" rel="noopener">http://YourDomainOrIPAddress/hello</a></strong> ，如果正常，它将会显示 “hello world”.</p><p>到这里我们已经正常部署项目，但是有一个问题，如果我们按 <strong>Ctrl-C</strong> 或 关闭运行服务器的终端窗口，它将停止工作。我们希望关闭当前会话服务也能正常运行，所以我们需要 <strong>Supervisor</strong> 协助我们管理进程通过后台来运行。</p><h2 id="四、安装并设置-Supervisor"><a href="#四、安装并设置-Supervisor" class="headerlink" title="四、安装并设置 Supervisor"></a>四、安装并设置 Supervisor</h2><h4 id="通过运行以下命令安装-Supervisor："><a href="#通过运行以下命令安装-Supervisor：" class="headerlink" title="通过运行以下命令安装 Supervisor："></a>通过运行以下命令安装 Supervisor：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update </span><br><span class="line">$ sudo apt-get install supervisor</span><br></pre></td></tr></table></figure><p>supervisor 配置需要放在 <strong>/etc/supervisor/conf.d/</strong> 目录下，以我们之前的项目 <strong>Hello</strong> 为例，在 <strong>/etc/supervisor/conf.d/</strong> 目录下创建一个 <strong>hello.conf</strong> 文件，输入以下配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[program:hello] # hello 即程序名称</span><br><span class="line">command=vapor run serve</span><br><span class="line">directory=/home/ubuntu/Hello # 项目路径</span><br><span class="line">user=ubuntu # 脚本运行的用户身份 </span><br><span class="line">stdout_logfile=/var/log/supervisor/%(program_name)-stdout.log</span><br><span class="line">stderr_logfile=/var/log/supervisor/%(program_name)-stderr.log</span><br></pre></td></tr></table></figure><h4 id="加载配置文件并使用-Supervisor-在后台运行-hello。"><a href="#加载配置文件并使用-Supervisor-在后台运行-hello。" class="headerlink" title="加载配置文件并使用 Supervisor 在后台运行 hello。"></a>加载配置文件并使用 Supervisor 在后台运行 <strong>hello</strong>。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl reread </span><br><span class="line">$ sudo supervisorctl add hello </span><br><span class="line">$ sudo supervisorctl start hello</span><br></pre></td></tr></table></figure><p>如无意外，现在你可以关闭终端，通过浏览器访问 <strong><a href="http://YourDomainOrIPAddress/hello" target="_blank" rel="noopener">http://YourDomainOrIPAddress/hello</a></strong> ，它将会显示 “hello world”.</p><h4 id="相关命令："><a href="#相关命令：" class="headerlink" title="相关命令："></a>相关命令：</h4><p>查看所有子进程的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl status</span><br></pre></td></tr></table></figure><p>关闭、开启所有的子进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl stop all</span><br><span class="line"></span><br><span class="line">$ sudo supervisorctl start all</span><br></pre></td></tr></table></figure><p>更新配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo supervisorctl update</span><br></pre></td></tr></table></figure><p>Enjoy 😊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Vapor 是基于 Swift 实现的 Web 框架与服务,可运行于 macOS 和 Ubuntu 系统上，本文主要记录如何使用 Nginx 和 Supervisor 部署 Vapor 应用程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Vapor" scheme="http://aidevjoe.github.io/tags/Vapor/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上更优雅的使用答题辅助脚本</title>
    <link href="http://aidevjoe.github.io/2018/01/13/%E5%9C%A8-macOS-%E4%B8%8A%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AD%94%E9%A2%98%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/"/>
    <id>http://aidevjoe.github.io/2018/01/13/在-macOS-上更优雅的使用答题辅助脚本/</id>
    <published>2018-01-13T07:29:57.000Z</published>
    <updated>2018-11-25T09:09:43.534Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Joe0708/TopSup-for-iOS" target="_blank" rel="noopener">Github 链接</a></p><p>在 macOS 上更优雅的使用答题辅助脚本, 基于 <a href="https://github.com/Skyexu/TopSup" target="_blank" rel="noopener">TopSup</a> 修改，删除了安卓平台相关代码</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Mac 和 iOS 双平台虽然可以使用 <a href="https://github.com/facebook/WebDriverAgent" target="_blank" rel="noopener">WDA</a> 来到达获取屏幕当前截图的目的，但是经体验 WDA 不仅安装非常多坑，譬如获取不到 ip、证书 或 端口转发 等问题，而且在 iPhone X 机型上经常无故断开，导致无法获取截图。基于这种情况所有想到了那外一种解决方案，利用 <strong>QuickTime</strong>。这里仅仅提供一种思路，可以参考后然后基于原仓库修改。</p><h2 id="概况"><a href="#概况" class="headerlink" title="概况:"></a>概况:</h2><ol><li>利用 QuickTime(或 AirServer 其他方案) 将 iPhone 投屏到 Mac 上</li><li>利用 macOS 自带的 <strong>screencapture</strong> 命令截图图片</li><li>利用原脚本完成剩余操作</li></ol><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h4 id="一、-利用-QuickTime-或-AirServer-其他方案-将-iPhone-投屏到-Mac-上"><a href="#一、-利用-QuickTime-或-AirServer-其他方案-将-iPhone-投屏到-Mac-上" class="headerlink" title="一、 利用 QuickTime(或 AirServer 其他方案) 将 iPhone 投屏到 Mac 上"></a>一、 利用 QuickTime(或 AirServer 其他方案) 将 iPhone 投屏到 Mac 上</h4><p>打开 <strong>QuickTime Player.app</strong>， 点击菜单栏-&gt;文件-&gt;新建影片录制, 点击录制按钮旁边的小箭头，选择你的 iPhone 即可，<a href="https://jingyan.baidu.com/article/59703552e714e48fc007402d.html" target="_blank" rel="noopener">具体教程</a></p><p><img src="http://ojpb4w81b.bkt.clouddn.com/18-1-12/84684463.jpg" alt=""></p><h4 id="二、利用-macOS-自带-screencapture-命令截图图片"><a href="#二、利用-macOS-自带-screencapture-命令截图图片" class="headerlink" title="二、利用 macOS 自带 screencapture 命令截图图片"></a>二、利用 macOS 自带 screencapture 命令截图图片</h4><p><strong>macOS</strong> 中内置了一个截图命令，既 <strong>screencapture</strong>，可通过 <code>screencapture --help</code> 查看帮助，其中有个 <strong>-R</strong> 参数可以指定截图区域，既 x,y,w,h。用过该命令获取 问题 和 答案选项 区域的截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screencapture -R&quot;20,190,310,100&quot; ./question_screenshot.png</span><br></pre></td></tr></table></figure><p>通过 <strong>Python</strong> os 模块中的 system 来调用 <strong>shell</strong> 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.system(&quot;screencapture -R\&quot;20,190,310,100\&quot; ./question_screenshot.png&quot;)</span><br></pre></td></tr></table></figure><h4 id="三、参考原脚本说明-配置-安装-ocr-及相应库即可"><a href="#三、参考原脚本说明-配置-安装-ocr-及相应库即可" class="headerlink" title="三、参考原脚本说明 配置/安装 ocr 及相应库即可"></a>三、参考<a href="https://github.com/Skyexu/TopSup" target="_blank" rel="noopener">原脚本说明</a> 配置/安装 ocr 及相应库即可</h4><p>参考<a href="https://github.com/Skyexu/TopSup" target="_blank" rel="noopener">原脚本说明</a> 配置/安装 ocr 及相应库。</p><p>参考 <strong>getQuestionAnswer.py</strong> 删除 WDA 相关代码，修改自己的坐标值，建议将 QuickTime 的窗口缩小再测量。</p><p>⚠️ 此 Demo 不会保持与原仓库的更新，仅供参考思路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Joe0708/TopSup-for-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 macOS 上更优雅的使用答题辅助脚本, 基于 &lt;a href
      
    
    </summary>
    
      <category term="Python" scheme="http://aidevjoe.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://aidevjoe.github.io/tags/Python/"/>
    
      <category term="脚本" scheme="http://aidevjoe.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Vim 复习笔记</title>
    <link href="http://aidevjoe.github.io/2018/01/05/Vim-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://aidevjoe.github.io/2018/01/05/Vim-复习笔记/</id>
    <published>2018-01-05T14:57:26.000Z</published>
    <updated>2018-11-26T07:08:31.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换模式"><a href="#切换模式" class="headerlink" title="切换模式"></a>切换模式</h3><ul><li>esc 进入命令模式</li><li>: 进入末尾模式</li></ul><h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><ul><li>i 光标前插入文本</li><li>I 行首插入文本</li><li>a 光标后插入文本 </li><li>A 行尾插入文本</li><li>o 下一行插入文本</li><li>O 上一行插入文本</li></ul><h3 id="复制粘贴删除"><a href="#复制粘贴删除" class="headerlink" title="复制粘贴删除"></a>复制粘贴删除</h3><ul><li>yy 复制光标所在行</li><li>4yy 光标所在行向下复制4行 </li><li>p 光标处粘贴</li><li>dd 删除/剪切 光标所在行</li><li>4dd 光标所在行向下 删除/剪切 4行</li><li>D 从当前光标处开始删除, 直到行尾</li><li>d0 从当前光标处开始删除, 直到行首 </li><li>u 撤销上一个操作</li><li>Ctrl+r 反撤销</li><li>x 删除光标处单个字符</li><li>X 删除光标处前一个字符</li><li>dw 删除光标所在的整个单词</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>r 替换光标处所选字符</li><li>R 替换光标处以后面的所有字符</li><li>:$s/hello/word/g 进入末尾模式并将所有的 hello 替换为 word</li><li>:10,20s/hello/word/g 进入末尾模式并 第10行直第20行之间将所有的 hello 替换为 word</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>/hello 进入查找模式, 并搜索 hello<br>a 下一个匹配处<br>A 上一个匹配处</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li>j 下</li><li>k 上</li><li>h 左</li><li>l 右</li><li>M 回到当前屏幕中间</li><li>H 回到当前屏幕上方</li><li>L 回到当前屏幕下方</li><li>Ctrl+f 向下翻一页</li><li>Ctrl+b 向上翻一页</li><li>Ctrl+u 向上翻半页</li><li>Ctrl+d 向下翻半页</li><li>11G 光标定位到第11行</li><li>Ctrl+G 回到文档底部</li><li>gg 回到文档顶部</li><li>w 跳到下一个单词的开始处</li><li>b 跳到上一个单词的开始处</li><li>{ 跳到上一段文本的开头</li><li>} 跳到下一段文本的尾部</li></ul><h3 id="选中操作"><a href="#选中操作" class="headerlink" title="选中操作"></a>选中操作</h3><ul><li>v 选中文本, 按字符移动</li><li>V 选中整行文本, 按行移动</li><li>&lt;&lt; 向左移动文本</li><li><blockquote><blockquote><p>向右移动文本</p></blockquote></blockquote></li><li>. 重复执行上一次操作</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>shift+zz 保存并退出 相当于 wq</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;切换模式&quot;&gt;&lt;a href=&quot;#切换模式&quot; class=&quot;headerlink&quot; title=&quot;切换模式&quot;&gt;&lt;/a&gt;切换模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;esc 进入命令模式&lt;/li&gt;
&lt;li&gt;: 进入末尾模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;插入文本&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Vim" scheme="http://aidevjoe.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://aidevjoe.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重新学 Linux 命令</title>
    <link href="http://aidevjoe.github.io/2018/01/05/%E9%87%8D%E6%96%B0%E5%AD%A6-Linux-%E5%91%BD%E4%BB%A4/"/>
    <id>http://aidevjoe.github.io/2018/01/05/重新学-Linux-命令/</id>
    <published>2018-01-05T14:08:52.000Z</published>
    <updated>2018-11-25T09:09:53.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>options</p><ul><li>-a  显示隐藏文件</li><li>-l  以列表显示当前目录的文件</li><li>-h  以可读方式显示文件大小</li></ul><h4 id="man-command-command-–help"><a href="#man-command-command-–help" class="headerlink" title="man command | command –help"></a>man command | command –help</h4><p>显示 command 的帮助信息</p><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>显示之前执行的历史命令<br>!index 直接执行指定索引的历史命令</p><h4 id="more-filename"><a href="#more-filename" class="headerlink" title="more filename"></a>more filename</h4><p>与 cat 不同的是显示一屏内容 按 f\b(上一页\下一页)内容</p><h4 id="command-gt-filename"><a href="#command-gt-filename" class="headerlink" title="command &gt; filename"></a>command &gt; filename</h4><p>重定向到指定文件</p><h4 id="command-gt-gt-filename"><a href="#command-gt-gt-filename" class="headerlink" title="command &gt;&gt; filename"></a>command &gt;&gt; filename</h4><p>以追加的形式重定向到指定文件</p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><ul><li>cd -  跳转到上一次的路径</li><li>cd ~  跳转到home目录</li><li>cd .. 当前目录的上一个目录</li><li>cd ../.. 当前目录的上一个目录的上一个目录, 可以无限类推</li></ul><h4 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h4><p>递归</p><h4 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h4><p>强制删除</p><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>带参数 -s 创建软链接, 不到参数即硬链接</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>从文件中的查找指定内容<br>-v 不包含指定搜索内容的内容<br>-n 显示行号</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find path “query”<br>-name 以文件名搜索<br>-size 按大小搜索<br>-perm 按权限</p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>对文件打包<br>tar [参数] 打包文件名 文件<br>-c 生成档案文件,创建打包文件<br>-v 显示详细过程和进度<br>-f 指定档案文件名称<br>-t 列出档案中所有文件<br>-x 解开档案文件<br>-z 压缩/解压 .gz 后缀压缩文件<br>-j 压缩/解压 .bz2 后缀压缩文件</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查找指定命令所在的目录</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>查看进程信息, 默认只查看当前程序的进程信息<br>-aux 查看所有进程</p><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p>查看当前用户</p><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>添加用户</p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户<br>-r 删除用户时同时删除用户主目录</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>设置/修改 用户密码</p><h4 id="groudadd"><a href="#groudadd" class="headerlink" title="groudadd"></a>groudadd</h4><p>创建用户组</p><h4 id="groupdell"><a href="#groupdell" class="headerlink" title="groupdell"></a>groupdell</h4><p>删除用户组</p><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>查看所有用户组</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>sudo usermod -a -G 组名 用户名<br>-a 添加到用户组<br>-G 组名</p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>查看当前登录用户</p><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>chown 组名 文件名<br>修改文件所有者</p><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>chgrp 组名 文件名<br>修改文件所属组</p><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>修改文件权限</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ls&quot;&gt;&lt;a href=&quot;#ls&quot; class=&quot;headerlink&quot; title=&quot;ls&quot;&gt;&lt;/a&gt;ls&lt;/h4&gt;&lt;p&gt;options&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a  显示隐藏文件&lt;/li&gt;
&lt;li&gt;-l  以列表显示当前目录的文件&lt;/li&gt;
&lt;li&gt;-h 
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://aidevjoe.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>fastlane boarding 实践笔记</title>
    <link href="http://aidevjoe.github.io/2017/12/23/fastlane-boarding-%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    <id>http://aidevjoe.github.io/2017/12/23/fastlane-boarding-实践笔记/</id>
    <published>2017-12-23T13:49:00.000Z</published>
    <updated>2018-11-25T09:10:11.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fastlane-boarding-实践笔记"><a href="#fastlane-boarding-实践笔记" class="headerlink" title="fastlane boarding 实践笔记"></a>fastlane boarding 实践笔记</h3><p>很长时间以来一直使用 <a href="https://wj.qq.com/" target="_blank" rel="noopener">腾讯问卷</a> 来收集 TestFlight 邮箱, 然后按模板导出SVG再导入到  iTunes Connect 中邀请测试, 如果有新的申请又得再次操作, 如此反复实在浪费精力.以至于后来懒得处理申请. 偶然发现 fastlane 自动化工具有个 <a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding</a> 服务专门用来简化这个功能, 只需要开发配置一下, 之后可以自动邀请, 完全不需要手工干预.</p><p><a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding Github</a> Github上已经有详情的教程</p><h4 id="操作教程"><a href="#操作教程" class="headerlink" title="操作教程"></a>操作教程</h4><ol><li>注册 <a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku</a> 账号</li><li><img src="https://camo.githubusercontent.com/c0824806f5221ebb7d25e559568582dd39dd1170/68747470733a2f2f7777772e6865726f6b7563646e2e636f6d2f6465706c6f792f627574746f6e2e706e67" alt=""> 部署到 Heroku</li><li>如图, 填写App名称, iTunes Connect 账号、邮箱、报名, 其他配置可按需设置<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmr00td9i3j30jg0w80tu.jpg" alt=""></li><li>点击 <strong>Deploy app</strong> 等待部署, 完成之后点击 <strong>View</strong> 即可</li></ol><blockquote><p>boarding 会自动根据填写的 <strong>App name</strong> 生成一个二级域名, 并获取App图标和名称, 如图示</p><p> <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmr042vna5j30cg0lbdg1.jpg" alt=""></p></blockquote><h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><p>二步验证登录</p><blockquote><p>如果设置<strong>二步验证登录</strong>, 可以按照此文件配置 <a href="https://github.com/fastlane/fastlane/blob/master/spaceship/README.md#2-step-verification" target="_blank" rel="noopener">2-step-verification</a> </p></blockquote><p>错误提示 “无默认外部组”</p><blockquote><p>打开 Heroku App的配置页面, 点击 Setting -&gt; Config Variables -&gt; Reveal Config Vars, 添加一个配置变量, 如图示<br> <img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmr080qgd7j30z60bsaak.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;fastlane-boarding-实践笔记&quot;&gt;&lt;a href=&quot;#fastlane-boarding-实践笔记&quot; class=&quot;headerlink&quot; title=&quot;fastlane boarding 实践笔记&quot;&gt;&lt;/a&gt;fastlane boarding 实践
      
    
    </summary>
    
      <category term="iOS" scheme="http://aidevjoe.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://aidevjoe.github.io/tags/iOS/"/>
    
      <category term="fastlane" scheme="http://aidevjoe.github.io/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>Chromium for macOS 内置插件、自定义及自动化脚本(二)</title>
    <link href="http://aidevjoe.github.io/2017/12/23/Chromium-for-macOS-%E5%86%85%E7%BD%AE%E6%8F%92%E4%BB%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC-(%E4%BA%8C)/"/>
    <id>http://aidevjoe.github.io/2017/12/23/Chromium-for-macOS-内置插件、自定义及自动化脚本-(二)/</id>
    <published>2017-12-23T10:43:05.000Z</published>
    <updated>2018-11-26T07:09:38.302Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul><li><a href="http://www.cnblogs.com/honker/p/6397591.html" target="_blank" rel="noopener">内置插件及简单的自定义</a></li></ul><blockquote><p>以下大部分操作参考链接中已有，里面有说到这里不再赘述。具体讲插件潜入和里面没有说到的点.本文所有操作以 <strong>Cam</strong>(公司插件) 插件为例</p></blockquote><h3 id="一、嵌入插件"><a href="#一、嵌入插件" class="headerlink" title="一、嵌入插件"></a>一、嵌入插件</h3><ol><li><p>添加插件</p><p> 将 Cam 插件源码文件夹，复制到 <strong>src\chrome\browser\resources\</strong> 文件夹目录下</p></li><li><p>修改组件加载源码</p><p> 打开 <strong>src\chrome\browser\extensions\component_loader.cc</strong> 文件，<br>在 <strong>AddDefaultComponentExtensions()</strong> 函数中添加:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add(IDR_LOVENSE_MANIFEST,</span><br><span class="line">    base::FilePath(FILE_PATH_LITERAL(&quot;lovense_cam&quot;)));</span><br></pre></td></tr></table></figure><p><img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/98106686.jpg" alt=""></p><blockquote><p>IDR_LOVENSE_MANIFEST 为插件资源目录的Key, 所有关联插件资源的Key都使用这个</p></blockquote><blockquote><p>lovense_cam 对应插件源码的文件夹名 </p></blockquote><ol start="3"><li><p>关联插件的 mainfest.json 文件</p><p> 打开 <strong>src\chrome\browser\browser_resources.grd</strong> 文件并添加以下代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include name=&quot;IDR_LOVENSE_MANIFEST&quot; file=&quot;resources\lovense_cam\manifest.json&quot; type=&quot;BINDATA&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/89964911.jpg" alt=""></p><ol start="4"><li><p>添加白名单</p><p> 打开 <strong>src\chrome\browser\extensions\component_extensions_whitelist\whitelist.cc</strong> 文件，在 <strong>bool IsComponentExtensionWhitelisted(int manifest_resource_id)</strong> 函数中的 <strong>switch</strong> 语句中添加以下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case IDR_LOVENSE_MANIFEST:</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://ojpb4w81b.bkt.clouddn.com/17-9-29/13887680.jpg)</code></pre><ol start="5"><li>添加插件文件路径映射关系</li></ol><p>打开 <strong>src\chrome\browser\resources\component_extension_resources.grd</strong> ，把除了mainfest.json文件之外的其他独立文件都加进来。</p><p>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include name=&quot;IDR_LOVENSE_128_PNG&quot;  file=&quot;lovense_cam\128.png&quot; type =&quot;BINDATA&quot; /&gt;</span><br></pre></td></tr></table></figure><p>附 Swift 脚本代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/// 转换XML之后的结果字符串</span><br><span class="line">var xmlString = &quot;&quot;</span><br><span class="line"></span><br><span class="line">/// 将插件文件夹内所有内容转换为XML 路径-&gt;文件名 键值对</span><br><span class="line">///</span><br><span class="line">/// - Parameter rootDir: 文件夹路径</span><br><span class="line">func convert2XML(rootDir: String) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        let folder = try FileManager.default.contentsOfDirectory(atPath: rootDir)</span><br><span class="line">        for itemPath in folder &#123;</span><br><span class="line">            let fullpath = rootDir.appending(&quot;/&quot; + itemPath)</span><br><span class="line">            let relPath = fullpath.replacingOccurrences(of: rootPath, with: parentDir)</span><br><span class="line">            </span><br><span class="line">            var isDir: ObjCBool = ObjCBool(false)</span><br><span class="line">            guard FileManager.default.fileExists(atPath: fullpath, isDirectory: &amp;isDir) else &#123; return &#125;</span><br><span class="line">            </span><br><span class="line">            if isDir.boolValue &#123;</span><br><span class="line">                convert2XML(rootDir: fullpath)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if [&quot;.DS_Store&quot;, &quot;manifest.json&quot;].contains(itemPath) &#123; continue &#125;</span><br><span class="line">                </span><br><span class="line">                let keyName = relPath</span><br><span class="line">                    .replacingOccurrences(of: &quot;/&quot;, with: &quot;_&quot;)</span><br><span class="line">                    .replacingOccurrences(of: &quot;.&quot;, with: &quot;_&quot;)</span><br><span class="line">                    .replacingOccurrences(of: &quot;-&quot;, with: &quot;_&quot;)</span><br><span class="line">                    .uppercased()</span><br><span class="line">                let xmlItem = &quot;&lt;include name=\&quot;IDR_&quot; + keyName + &quot;\&quot; file=\&quot;\(relPath)\&quot; type=\&quot;BINDATA\&quot; /&gt;&quot;</span><br><span class="line">                xmlString.append(xmlItem + &quot;\n&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(error)</span><br><span class="line">        exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tip：必须保证 key 不能有重复的<br>Lovense Browser 每次打包时， 如果插件资源文件有添加或删除需要重新生成。</p></blockquote><h3 id="二、其他修改"><a href="#二、其他修改" class="headerlink" title="二、其他修改"></a>二、其他修改</h3><ol><li><p>修改 Chromium 关于页面的名字<br>修改 <strong>src/chrome/app/settings_chromium_strings.grdp</strong> 文件中的 <strong>IDS_SETTINGS_ABOUT_PROGRAM</strong> 对应的值</p></li><li><p>修改 Chromium 关于页面的版本号<br>修改 <strong>src/out/Lovense/gen/components/version_info/version_info_values.h</strong> 文件中的 <strong>PRODUCT_VERSION</strong> 对应的值</p></li><li><p>注释掉从 DMG磁盘镜像中打开 Chromium 提示已到应用程序文件夹中的提示（引发此操作是 Chromium 内核，如果移到应用程序中， 只有 Chromium 内核会移过去，而启动器不会， 所以直接注释掉）</p><p> 打开 <strong>src/chrome/browser/chrome_browser_main_mac.mm</strong> 文件，注释掉<strong> void ChromeBrowserMainPartsMac::PreMainMessageLoopStart()</strong> 函数中 <strong>IsFirstRunSuppressed</strong> 判断</p><p> <img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/274156.jpg" alt=""></p></li></ol><h3 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h3><p>参考 <a href="http://192.168.0.5/zentao/doc-view-135.html" target="_blank" rel="noopener">编译教程</a></p><blockquote><p>添加资源文件后，编译可能会提示Key越界, 需将 <strong>src/tools/gritsettings/resource_ids</strong> 文件中中includes的值调大</p></blockquote><p><img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/56964818.jpg" alt=""></p><h3 id="四、打包"><a href="#四、打包" class="headerlink" title="四、打包"></a>四、打包</h3><ol><li>打开 <strong>LovenseBrowser.xcodeproj</strong> 项目，导出 <strong>iPa</strong> 安装包</li><li>src/out/Release/Lovense Browser 拷贝到 LovenseBrowser.app/ 目录中</li><li>修改启动器名字 Lovense Browser</li><li>使用 DropDMG 打包</li><li>将Lovense Browser.dmg和Lovense_Browser_Mac_Update.zip上传到服务器并更新后台版本号即可</li></ol><h3 id="五、脚本"><a href="#五、脚本" class="headerlink" title="五、脚本"></a>五、脚本</h3><p>以上所有操作均已使用脚本自动化</p><p>脚本地址：<a href="https://github.com/Joe0708/ChromiumBuild/tree/master" target="_blank" rel="noopener">Github</a></p><p><strong>chromiumBuild.sh</strong> : 主要用于 depot_tools 下载、 Chromium 源码自动下载编译，源码安装好后不需要再使用</p><p><strong>buildStarter.swift</strong> ： 主要用于每次打包时自动将插件文件夹复制到指定位置，自动生成文件映射关系并替换，并修改软件版本号</p><p><strong>build.sh</strong> : 主要用于编译 Chromium，打包 ipa 包，制作 DMG、Zip 文件</p><h3 id="六、自动化脚本使用"><a href="#六、自动化脚本使用" class="headerlink" title="六、自动化脚本使用"></a>六、自动化脚本使用</h3><ol><li><p>下载脚本源码</p></li><li><p>打开终端</p></li></ol><blockquote><ol><li>运行 buildStarter.swift 脚本，根据提示输入插件路径和版本号</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./buildStarter.swift</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>运行 build.sh 脚本， 编译 Chromium、打包、制作 DMG、Zip 文件</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 如果终端提示没有权限，需在终端执行以下命令</p><p> chmod +x buildStarter.swift</p></blockquote><blockquote><p> chmod +x build.sh</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;参考链接：&quot;&gt;&lt;a href=&quot;#参考链接：&quot; class=&quot;headerlink&quot; title=&quot;参考链接：&quot;&gt;&lt;/a&gt;参考链接：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/honker/p/6397591.htm
      
    
    </summary>
    
    
      <category term="Chromium" scheme="http://aidevjoe.github.io/tags/Chromium/"/>
    
  </entry>
  
  <entry>
    <title>Chromium for macOS 编译教程(一)</title>
    <link href="http://aidevjoe.github.io/2017/12/23/Chromium-for-macOS-%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B(%E4%B8%80)/"/>
    <id>http://aidevjoe.github.io/2017/12/23/Chromium-for-macOS-编译教程(一)/</id>
    <published>2017-12-23T08:13:50.000Z</published>
    <updated>2018-11-26T07:06:04.908Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><ul><li>Mac (requied 10.11+)</li><li>Xcode IDE（required 7.3+）</li><li>Git（required 2.2.1+）</li><li>科学上网</li></ul><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul><li><p><a href="https://chromium.googlesource.com/chromium/src/+/lkcr/docs/mac_build_instructions.md" target="_blank" rel="noopener">官方编译教程</a></p></li><li><p><a href="https://www.chromium.org/developers/how-tos/get-the-code/working-with-release-branches" target="_blank" rel="noopener">官方 Release 分支编译教程</a></p></li><li><p><a href="http://www.cnblogs.com/honker/p/6397591.html" target="_blank" rel="noopener">内置插件及简单的自定义</a></p></li><li><p><a href="https://blink.lc/chromium/" target="_blank" rel="noopener">Chromium Release版本 信息</a></p></li></ul><h4 id="步骤概括："><a href="#步骤概括：" class="headerlink" title="步骤概括："></a>步骤概括：</h4><ol><li>安装 depot_tools 项目构建工具</li><li>使用 depot_tools 下载源码</li><li>编译 Chromium 源码</li><li>编译稳定版（Stable）分支</li></ol><h3 id="一、安装-depot-tools-项目构建工具"><a href="#一、安装-depot-tools-项目构建工具" class="headerlink" title="一、安装 depot_tools 项目构建工具"></a>一、安装 depot_tools 项目构建工具</h3><ol><li>克隆 depot_tools git仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure><ol start="2"><li>添加环境变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=&quot;$PATH:/path/to/depot_tools&quot;</span><br></pre></td></tr></table></figure><blockquote><p>Tip: <strong>/path/to/depot_tools</strong>， 为你 depot_tools 本地的路径</p></blockquote><h3 id="二、使用-depot-tools-下载源码"><a href="#二、使用-depot-tools-下载源码" class="headerlink" title="二、使用 depot_tools 下载源码"></a>二、使用 depot_tools 下载源码</h3><ol><li>创建一个用于存在 chromium 的目录 (您可以任意命令，并存放在任何您喜欢的位置，只要是路径路径并且没有空格即可）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir chromium &amp;&amp; cd chromium</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 depot_tools 的 fetch 命令，来检查代码及其依赖关系。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fetch --no-history chromium</span><br></pre></td></tr></table></figure><blockquote><p>Tip: –no-history： 代表不需要历史记录， 完整仓库大约40G<br>        源码大小大概 8G 左右，下载时间因网速而议，请耐心等待</p></blockquote><h3 id="三、编译-Chromium-源码"><a href="#三、编译-Chromium-源码" class="headerlink" title="三、编译 Chromium 源码"></a>三、编译 Chromium 源码</h3><ol><li>进入源码目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br></pre></td></tr></table></figure><ol start="2"><li>生成编译配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn args out/Release</span><br></pre></td></tr></table></figure><blockquote><p>out/<strong>Release</strong> 中 Release 并非固定，可以随意取名</p></blockquote><ol start="3"><li>设置编译配置选项</li></ol><p>执行以上命令之后，此时会进入 Vim 编辑模式<br>按字母键 <code>o</code> 进入编辑模式，粘贴一下配置项<br>按 <code>:wq</code> 退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target_cpu = &quot;x64&quot;</span><br><span class="line">is_debug = false</span><br><span class="line">symbol_level = 0</span><br><span class="line">enable_nacl = true</span><br><span class="line">remove_webcore_debug_symbols = true</span><br><span class="line">ffmpeg_branding = &quot;Chrome&quot;</span><br><span class="line">proprietary_codecs = true</span><br><span class="line">enable_iterator_debugging = false</span><br><span class="line">exclude_unwind_tables = true</span><br></pre></td></tr></table></figure><blockquote><p>具体配置信息见：<a href="https://chromium.googlesource.com/chromium/src/+/lkcr/tools/gn/docs/quick_start.md" target="_blank" rel="noopener">链接</a></p></blockquote><ol start="4"><li>编译代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ninja -C out/Release chrome</span><br></pre></td></tr></table></figure><blockquote><p>out/<strong>Release</strong> 中 Release 并非固定，可以随意取名</p></blockquote><ol start="5"><li>运行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ out/Release/Chromium.app/Contents/MacOS/Chromium</span><br></pre></td></tr></table></figure><blockquote><p>编译文件大约 3W 左右， 需要 4-8 个小时</p></blockquote><h3 id="四、编译稳定版（Stable）分支"><a href="#四、编译稳定版（Stable）分支" class="headerlink" title="四、编译稳定版（Stable）分支"></a>四、编译稳定版（Stable）分支</h3><ol><li>检查分支（option）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --tags</span><br></pre></td></tr></table></figure><ol start="2"><li>根据指定分支创建分支，并切换到该分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b LovenseBrowser_61.0.3163.100 tags/61.0.3163.100</span><br></pre></td></tr></table></figure><ol start="3"><li>同步代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gclient sync --with_branch_heads --jobs 16</span><br></pre></td></tr></table></figure><ol start="4"><li>编译代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ninja -C out/Release chrome</span><br></pre></td></tr></table></figure><ol start="5"><li>运行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ out/Release/Chromium.app/Contents/MacOS/Chromium</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 同第三步中的第4、5步</p></blockquote><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>以上所以步骤均已写入脚本，可以使用脚本代替。</p><p>脚本链接： <a href="https://github.com/Joe0708/ChromiumBuild/blob/master/chromiumBuild.sh" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;准备工作：&quot;&gt;&lt;a href=&quot;#准备工作：&quot; class=&quot;headerlink&quot; title=&quot;准备工作：&quot;&gt;&lt;/a&gt;准备工作：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Mac (requied 10.11+)&lt;/li&gt;
&lt;li&gt;Xcode IDE（required 7.3
      
    
    </summary>
    
    
      <category term="Chromium" scheme="http://aidevjoe.github.io/tags/Chromium/"/>
    
  </entry>
  
  <entry>
    <title>Call to undefined function mysql_connect()</title>
    <link href="http://aidevjoe.github.io/2016/11/21/Call%20to%20undefined%20function%20mysql%20connect/"/>
    <id>http://aidevjoe.github.io/2016/11/21/Call to undefined function mysql connect/</id>
    <published>2016-11-21T02:23:16.000Z</published>
    <updated>2018-11-25T09:09:57.290Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习PHP连接mysql,对着教程练习,代码什么都没问题,但是总无法连接成功,提示调用了未定义的函数,错误如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call to undefined function mysql_connect()</span><br></pre></td></tr></table></figure><p>网上胡乱搜了一番, 都是说<strong>PHP.ini</strong>文件配置问题.</p><p>SO, 屁颠屁颠的去找这个文件按照网上的答案改什么 <strong>extension_dir</strong>, 放开<strong>extension=php_mysql.dll</strong>的注释, Command + F ,结果啥也没搜到, WTF(黑人脸).这下懵逼了.</p><p>因为用的是Mac电脑,所以以为是系统原因导致配置文件的格式不一样? 结果又搜索了一番, 还是无果.机智如我,最后看了文档手册才发现<strong>PHP7</strong>已经废掉了mysql模块,官方推荐使用<strong>mysqli</strong>和<strong>PDO</strong>, 最后使用了最新模块顺利解决问题!</p><p>oh yeah~</p><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f9yr3mp2j6j20jc0f6ab5.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9yr51f501j20om05aq3a.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习PHP连接mysql,对着教程练习,代码什么都没问题,但是总无法连接成功,提示调用了未定义的函数,错误如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="PHP" scheme="http://aidevjoe.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://aidevjoe.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="http://aidevjoe.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础 - 增删改查</title>
    <link href="http://aidevjoe.github.io/2016/11/21/SQL%E5%9F%BA%E7%A1%80-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://aidevjoe.github.io/2016/11/21/SQL基础-增删改查/</id>
    <published>2016-11-21T02:20:40.000Z</published>
    <updated>2018-11-25T09:10:20.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、增加记录"><a href="#1、增加记录" class="headerlink" title="1、增加记录"></a>1、增加记录</h2><pre><code>语法格式: insert into table_name(field 1,field2, field3,...) values(value 1,value 2, value 3,...)语法说明:     * insert into : 添加数据的SQL命令.    * table_name : 要添加数据的数据表名.    * 表的字段列表, 要与值的列表一一对应.    * 字段的类型,要与值类型一致.    * 如果还有没列出的字段, 将用默认值代替.举例:    insert into student(name, gender, profile) values (&apos;Joe&apos;,1,&apos;大家好,我在学习SQL&apos;);</code></pre><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9ylprvw7tj20vk09swgb.jpg" alt=""></p><h2 id="2、删除记录"><a href="#2、删除记录" class="headerlink" title="2、删除记录"></a>2、删除记录</h2><pre><code>语法格式: delete from table_name [where 条件]语法说明:    * delete from : 删除数据的SQL命令.    * table_name : 要删除数据的数据表名.    * where 条件 : 如果省略条件, 将删除所有记录.举例:     * delete from student : //删除所有记录    * delete from student where id&gt;10; //删除 id&gt;10 的所有记录    * delete from student where id&gt;19 and id&lt;20; //删除 id&gt;10 并且 id&lt;20 的所有记录    * delete from student where name=&apos;Joe&apos; and id&lt;100; //删除 name=&apos;Joe&apos; 并且 id&lt;100的所有记录</code></pre><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f9ylz8r2d0j20kg0fk777.jpg" alt=""></p><h2 id="3、修改记录"><a href="#3、修改记录" class="headerlink" title="3、修改记录"></a>3、修改记录</h2><pre><code>语法格式: update table_name set 字段1=新值1, 字段2=新值2,... [where 条件]语法说明:    * 需要更新的字段列出, 不需要更新的不用管.    * 字段的顺序可以修改.    * where 条件不能省略, 如果省略会导致所有记录都会修改成一样举例:</code></pre><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9ym5mralqj20to08m761.jpg" alt=""></p><h2 id="4、查询记录"><a href="#4、查询记录" class="headerlink" title="4、查询记录"></a>4、查询记录</h2><pre><code>语法格式: select 字段列表 | * from table_name [where 条件] [order by 排序] [limit 限制条数]语法说明:    * 字段列表 : 查询某些字段的数据, 各字段之间用逗号隔开, 字段之间不分顺序    * &apos;*&apos; : 表示显示所有列数据 如: select * from student;    * where : 查询指定的条件的数据        - select * from student where id&lt;10;        - select * from student where id&lt;100 and gender=1;        - select * from student where id=100 or gender=0;    * order by : 字段排序        - 语法 : order by 字段 [asc | desc].        - asc 表示 &quot;升序&quot; 排列(默认), desc 表示 &quot;降序&quot;排列.        - select * from student order by id desc; //id 降序排列    * limit : 限制输出        - 语法 : limit startrow,pagesize        - 参数 :             * startrow 从指定的行数起开发返回数据.            * pagesize 返回的记录数        - 举例 :            * limit 0,10; //从第0行起,返回10条记录            * limit 10,10; //从第10行起,返回10条记录            * limot 20,10; //从第20行起,返回10条记录 </code></pre><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:center">名称</th><th style="text-align:right">应用</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:center">等于</td><td style="text-align:right">id=3</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:center">大于</td><td style="text-align:right">id&gt;5</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:center">小于</td><td style="text-align:right">id&lt;5</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:right">id&gt;=5</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:center">小于等于</td><td style="text-align:right">id&lt;=5</td></tr><tr><td style="text-align:left">!=或者&lt;&gt;</td><td style="text-align:center">不等于</td><td style="text-align:right">id!=5</td></tr><tr><td style="text-align:left">is not null</td><td style="text-align:center">不为空</td><td style="text-align:right">id is not null</td></tr><tr><td style="text-align:left">is null</td><td style="text-align:center">为空</td><td style="text-align:right">title is null</td></tr><tr><td style="text-align:left">bwtween</td><td style="text-align:center">两者之间</td><td style="text-align:right">id between 1 and 10</td></tr><tr><td style="text-align:left">in</td><td style="text-align:center"></td><td style="text-align:right">id in(1,3,5)</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:center"></td><td style="text-align:right">id not in(1,3,5)</td></tr><tr><td style="text-align:left">like</td><td style="text-align:center">模式匹配</td><td style="text-align:right">name like(‘jerry%’)</td></tr><tr><td style="text-align:left">not like</td><td style="text-align:center">模式匹配</td><td style="text-align:right">name not like(‘jerry%’);</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、增加记录&quot;&gt;&lt;a href=&quot;#1、增加记录&quot; class=&quot;headerlink&quot; title=&quot;1、增加记录&quot;&gt;&lt;/a&gt;1、增加记录&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;语法格式: insert into table_name(field 1,field2, f
      
    
    </summary>
    
      <category term="PHP" scheme="http://aidevjoe.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://aidevjoe.github.io/tags/PHP/"/>
    
      <category term="SQL" scheme="http://aidevjoe.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库基本操作</title>
    <link href="http://aidevjoe.github.io/2016/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://aidevjoe.github.io/2016/11/21/数据库基本操作/</id>
    <published>2016-11-21T02:15:36.000Z</published>
    <updated>2018-11-25T09:09:38.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-数据库操作"><a href="#MySQL-数据库操作" class="headerlink" title="MySQL 数据库操作"></a>MySQL 数据库操作</h2><h3 id="1、登陆到MySQL服务器"><a href="#1、登陆到MySQL服务器" class="headerlink" title="1、登陆到MySQL服务器"></a>1、登陆到MySQL服务器</h3><pre><code>语法格式 : mysql -u用户名 -p密码参数说明 : * /Applications/MAMP/Library/bin/mysql : 代表mysql的主程序 * -u : 代表MySQL用户名,后面紧跟密码, 如 -uroot * -p : 代表MySQL密码, 后面紧跟密码, 如 -proot举例:     /Applications/MAMP/Library/bin/mysql -uroot -proot</code></pre><h3 id="2、显示所有已有数据库"><a href="#2、显示所有已有数据库" class="headerlink" title="2、显示所有已有数据库"></a>2、显示所有已有数据库</h3><pre><code>语法格式 : show databases;</code></pre><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f9yfx4bzvuj20ag07imxv.jpg" alt=""></p><h3 id="3、-创建数据库"><a href="#3、-创建数据库" class="headerlink" title="3、 创建数据库"></a>3、 创建数据库</h3><pre><code>语法格式 : create database [if not exists] db_name [charset utf8]参数说明    * create database : MySQL命令,创建一个数据库    * if not exists : 可选项,如果这个数据库不存在则创建数据库.    * db_name : 数据库的名称    * charset : 可选项,设置数据库的字符集(默认lain1)举例: create database if not exists student charset utf8;</code></pre><p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f9yg6s52oaj20aw08ot9g.jpg" alt=""></p><h3 id="4、-删除数据库"><a href="#4、-删除数据库" class="headerlink" title="4、 删除数据库"></a>4、 删除数据库</h3><pre><code>语法格式 : drop database [if exists] db_name;参数说明    * drop database: MySQL命令, 删除一个数据库    * if exists : 可选项, 如果存在则删除数据库    * db_name : 数据库名举例: drop database if exists student;</code></pre><h3 id="5、MySQL数据库字符集"><a href="#5、MySQL数据库字符集" class="headerlink" title="5、MySQL数据库字符集"></a>5、MySQL数据库字符集</h3><ol><li><p>查看数据库的字符集</p><pre><code>语法格式 : show create database db_name;举例: show create database student;</code></pre><p> <img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f9ygdx6tb4j20vg09u404.jpg" alt=""></p></li><li><p>修改数据库的字符集</p><pre><code>语法格式 : alter database db_name default character set utf8;举例: alter database student default character set utf8;</code></pre></li></ol><h2 id="MySQL-数据表操作"><a href="#MySQL-数据表操作" class="headerlink" title="MySQL 数据表操作"></a>MySQL 数据表操作</h2><h3 id="1、选择数据库"><a href="#1、选择数据库" class="headerlink" title="1、选择数据库"></a>1、选择数据库</h3><pre><code>描述 : 选择所需要操作的数据库语法格式 : user db_name    举例: user student;</code></pre><h3 id="2、显示所有的数据表"><a href="#2、显示所有的数据表" class="headerlink" title="2、显示所有的数据表"></a>2、显示所有的数据表</h3><pre><code>描述 : 选择当前所操作数据库下的所有数据表语法格式 : show tables</code></pre><h3 id="3、创建数据表"><a href="#3、创建数据表" class="headerlink" title="3、创建数据表"></a>3、创建数据表</h3><pre><code>描述 : 在当前数据库中创建一个数据表语法格式 : create table table_name(col_name col_type col_attr,col_name col_type col_attr,...)参数说明 :    * create table : 创建一个数据表    * table_name : 数据表表名    * col_name : 列的名称    * col_type : 列的类型.(eg: tinyint、int、bigint、char、varchar、text、date、time等)    * col_attr : 列的属性        - not null | null : 该列是否可以为空.        - default default_value : 指定该列的默认值.        - default_value 默认是字符串, 也可以是整型        - auto_increment : 该列值为自动增长型,或者自动编号.类型必须是整型        - primary key : 主键. 指定该列的值具有唯一性, 不能为空.(配合 not null 使用), 一个表只能有一个主键        - id 字段的属性必须有: not null auto_increment primary key注意: 一个数据表,由多个列构成.多个列定义之间用英文逗号隔开举例: </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; create table student(</span><br><span class="line">   id int not null auto_increment primary key,</span><br><span class="line">   name varchar(20) not null,</span><br><span class="line">   gender tinyint,</span><br><span class="line">  profile text</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p> <img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9yjjuovs1j20ju0cy404.jpg" alt=""></p><h3 id="4、查看数据表结构"><a href="#4、查看数据表结构" class="headerlink" title="4、查看数据表结构"></a>4、查看数据表结构</h3><pre><code>语法格式 : describe table_name;举例 : describe student;</code></pre><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9yjrevf9pj20pw08i762.jpg" alt=""></p><h3 id="5、修改数据表"><a href="#5、修改数据表" class="headerlink" title="5、修改数据表"></a>5、修改数据表</h3><pre><code>语法格式 : alter table举例 : 详情可参考MySQL语法手册, 在此不演示</code></pre><h3 id="6、删除数据表"><a href="#6、删除数据表" class="headerlink" title="6、删除数据表"></a>6、删除数据表</h3><pre><code>语法格式 : drop table [if exists] table_name;举例 : drop table student;</code></pre><h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><ol><li>整型浮点型</li></ol><ul><li>整型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">描述</th><th style="text-align:right">范围</th><th style="text-align:right">大小</th></tr></thead><tbody><tr><td style="text-align:left">tinyint</td><td style="text-align:center">最小型整数</td><td style="text-align:right">0~255(-128 ~ + 127)</td><td style="text-align:right">一个字节</td></tr><tr><td style="text-align:left">smallint</td><td style="text-align:center">小型整数</td><td style="text-align:right">0~65535</td><td style="text-align:right">二个字节</td></tr><tr><td style="text-align:left">mediumint</td><td style="text-align:center">中型整数</td><td style="text-align:right">0~1677万</td><td style="text-align:right">三个字节</td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">一般整数</td><td style="text-align:right">0~21亿</td><td style="text-align:right">四个字节</td></tr><tr><td style="text-align:left">bigint</td><td style="text-align:center">最大整数</td><td style="text-align:right">0~42亿</td><td style="text-align:right">八个字节</td></tr></tbody></table><ul><li>浮点型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">范围</th><th style="text-align:right">描述</th><th style="text-align:right">举例</th></tr></thead><tbody><tr><td style="text-align:left">float(m,d)</td><td style="text-align:center">单精度(精确到小数点后7位)</td><td style="text-align:right">M代表长度, D代表小数位数</td><td style="text-align:right">float(6,2) 总长度为6位,小数位为2位,小数点不算,最大值为9999.99</td></tr><tr><td style="text-align:left">double(m.d)</td><td style="text-align:center">双精度(精确到小数点后15位)</td><td style="text-align:right">M代表长度, D代表小数位数</td><td style="text-align:right"></td></tr></tbody></table><ol start="2"><li>日期时间型</li></ol><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">描述</th><th style="text-align:right">格式</th></tr></thead><tbody><tr><td style="text-align:left">date</td><td style="text-align:center">日期型</td><td style="text-align:right">“YYYY-MM-DD”</td></tr><tr><td style="text-align:left">time</td><td style="text-align:center">时间型</td><td style="text-align:right">“00:00:00”</td></tr></tbody></table><ol start="3"><li>字符、文本型</li></ol><ul><li>字符型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">范围</th><th style="text-align:right">描述</th><th style="text-align:right">大小</th><th>举例</th></tr></thead><tbody><tr><td style="text-align:left">char(m)</td><td style="text-align:center">0~255</td><td style="text-align:right">m代表长度, 固定长度的字符串</td><td style="text-align:right">一个字节</td><td>如:邮编、手机号码、电话号码等</td></tr><tr><td style="text-align:left">varchar(m)</td><td style="text-align:center">0~65535</td><td style="text-align:right">m代表长度, 可变长度的字符串</td><td style="text-align:right">二个字节</td><td>如:新闻标题、家庭地址、毕业院校等</td></tr></tbody></table><ul><li>文本型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">范围</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:left">tinytext</td><td style="text-align:center">0~255</td><td style="text-align:right">小型文本</td></tr><tr><td style="text-align:left">text</td><td style="text-align:center">0~1670万</td><td style="text-align:right">中型文本</td></tr><tr><td style="text-align:left">longtext</td><td style="text-align:center">0~42亿</td><td style="text-align:right">大型文本</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-数据库操作&quot;&gt;&lt;a href=&quot;#MySQL-数据库操作&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库操作&quot;&gt;&lt;/a&gt;MySQL 数据库操作&lt;/h2&gt;&lt;h3 id=&quot;1、登陆到MySQL服务器&quot;&gt;&lt;a href=&quot;#1、登陆
      
    
    </summary>
    
      <category term="PHP" scheme="http://aidevjoe.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://aidevjoe.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="http://aidevjoe.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>利用 CrossOver 安装Windows应用程序</title>
    <link href="http://aidevjoe.github.io/2016/10/24/%E5%88%A9%E7%94%A8-CrossOver-%E5%AE%89%E8%A3%85Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://aidevjoe.github.io/2016/10/24/利用-CrossOver-安装Windows应用程序/</id>
    <published>2016-10-24T01:35:23.000Z</published>
    <updated>2018-11-25T09:09:22.688Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前言: 鉴于最近太多人问软件使用教程, 这里拿Windows版微信的安装做个简单演示, 其他软件安装流程一样</span><br></pre></td></tr></table></figure><hr><h2 id="步骤-一"><a href="#步骤-一" class="headerlink" title="步骤 一:"></a>步骤 一:</h2><p>打开软件后 <strong>点击安装 Windows 应用程序</strong></p><p><img src="http://ww4.sinaimg.cn/large/801b780agw1f920mb3t1fj216o10e424.jpg" alt="image"></p><hr><h2 id="步骤-二"><a href="#步骤-二" class="headerlink" title="步骤 二:"></a>步骤 二:</h2><p>输入你要安装的Windows软件, 如果列表中没有,选择 <strong>未列出的应用程序”xxxx”</strong> ,然后点击右下角继续</p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f921n1ln69j212g0y40v3.jpg" alt=""></p><hr><h2 id="步骤-三"><a href="#步骤-三" class="headerlink" title="步骤 三:"></a>步骤 三:</h2><p>点击 <strong>选择安装文件</strong> , 选择你要安装的Windows应用程序的安装包, 这里我已经提前将Windows版的微信下载下来, 直接选择安装包后点击<strong>继续</strong>然后<strong>安装</strong>即可。 如果你没有安装包, 需要先下载安装包</p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f920rjopklj219414s0yh.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f921pprk6lj21320yyjvc.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f921qetg99j21320ymgpf.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/801b780agw1f921qwz7mgj213c0ycn04.jpg" alt=""></p><hr><h2 id="步骤-四"><a href="#步骤-四" class="headerlink" title="步骤 四:"></a>步骤 四:</h2><p>到这一步, 软件会自动安装, 如果软件依赖的框架或运行环境较多, 就会导致安装过程比较长,请耐心等待</p><p>安装过程中会出现跟Windows上一样的安装过程, 按正常的流程安装即可</p><p>安装流程完成请退出你安装的软件,如果软件在运行过程中,会阻塞CrossOver的正常安装</p><p><img src="http://ww1.sinaimg.cn/large/801b780agw1f921rkd4t0j213e0yqwi0.jpg" alt=""></p><hr><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>利用Crossover成功将微信安装在Mac上,但是使用时却发现输入文字时输入框并没有文字显示</p><p>可以总结出软件兼容性不是很好,所有这里并不建议大家安装大型软件或游戏, 安装一些小应用倒无妨</p><p>如果你实在需要运行但Crossover无法兼容满足你的软件, 你还可以用虚拟机来代替。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>视频操作教程: <a href="https://pan.baidu.com/s/1pLhdljX" target="_blank" rel="noopener">链接</a> 密码: <strong>4ezh</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="软件" scheme="http://aidevjoe.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="macOS" scheme="http://aidevjoe.github.io/tags/macOS/"/>
    
      <category term="CrossOver" scheme="http://aidevjoe.github.io/tags/CrossOver/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS Sierra(10.12) 安全与隐私没有允许任何来源的选项 </title>
    <link href="http://aidevjoe.github.io/2016/09/22/%E8%A7%A3%E5%86%B3-macOS-Sierra-10-12-%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81%E6%B2%A1%E6%9C%89%E5%85%81%E8%AE%B8%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90%E7%9A%84%E9%80%89%E9%A1%B9/"/>
    <id>http://aidevjoe.github.io/2016/09/22/解决-macOS-Sierra-10-12-安全与隐私没有允许任何来源的选项/</id>
    <published>2016-09-22T05:37:32.000Z</published>
    <updated>2018-11-25T09:24:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>不少用户更新到最新系统 <strong>macOS Sierra</strong> 后发现系统偏好设置-&gt;安全性与隐私中默认已经隐藏了运行安装任何来源App的选项, 如图<br><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f82boff8etj20g40di3z6.jpg" alt="image"></p><p>因为增强了GateKeeper的安全性，所以该选项被隐藏，目的在于避免除Mac AppStore和正规签名外的未知或未签名App在系统内被任意执行，从而威胁用户隐私和系统安全。但这也导致很多不是从AppStore中下载的软件或破解版的软件将无法使用, 这也造成了很多不便。在<strong>macOS Sierra</strong>系统中<strong>GateKeeper</strong> 默认是打开的, 所以我们只需关掉<strong>GateKeeper</strong>即可看到<strong>任何来源</strong>的选项了</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>1.打开应用程序-&gt;实用工具-&gt;终端</p><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f82bc2itoyj20oi0f8jtp.jpg" alt="image"></p><p>2.在终端中输入命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>3.敲回车, 然后验证口令后即可(电脑密码, 注意:输入密码时屏幕上不会有任何显示,实际已经输入,输入完后敲回车即可)。</p><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f82bqnrca6j20i60ci74l.jpg" alt="image"></p><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f82bpp0eovj20lo0i6dh5.jpg" alt="image"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果你不想打开这个全局设置, 你也可以针对某个应用开启选项</p><p>同上操作,输入命令时换成以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/应用.app</span><br></pre></td></tr></table></figure></p><p>注意 “应用.app” 换成你需要解锁的app, 例如QQ的安装路径是 /Applications/QQ.app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/QQ.app</span><br></pre></td></tr></table></figure></p><p>如果不会操作可以下载这个命令行脚本, 解压后打开运行直接输入电脑密码即可</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1qXE9vEs" target="_blank" rel="noopener">https://pan.baidu.com/s/1qXE9vEs</a> 密码: 7rwq</p></blockquote><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">Apple</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不少用户更新到最新系统 &lt;strong&gt;macOS Sierra&lt;/strong&gt; 后发现系统偏好设置-&amp;gt;安全性与隐私中默认已经隐藏了运行安装任何来源App的选项, 如图&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/65e4f1e
      
    
    </summary>
    
      <category term="macOS" scheme="http://aidevjoe.github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://aidevjoe.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>利用 AFNetworking + YYCache 对网络请求进行简单缓存</title>
    <link href="http://aidevjoe.github.io/2016/09/14/%E5%88%A9%E7%94%A8-AFNetworking-YYCache-%E5%AF%B9%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%BC%93%E5%AD%98/"/>
    <id>http://aidevjoe.github.io/2016/09/14/利用-AFNetworking-YYCache-对网络请求进行简单缓存/</id>
    <published>2016-09-14T08:45:34.000Z</published>
    <updated>2018-11-25T09:09:11.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在开发中我们常常需要向服务器发送请求来获得数据, 正常的流程是这样:</p><ol><li>发送请求</li><li>网络正常, 将数据刷新到UI</li><li>无网络，没有数据, 视图空白</li></ol><p>这样就会导致同一个URL请求多次，服务器返回的数据可能都是一样的，比如服务器上的某张图片，无论下载多少次，返回的数据都是一样的。这样的情况可能会导致一下问题:</p><ol><li>重复获取数据，造成用户流量的浪费</li><li>请求响应速度可能很慢</li><li>服务器不必要的压力</li><li>没网络的情况下没有数据</li><li>…</li></ol><p>所以为了解决上面的问题，我们一般会对数据进行缓存处理，给用户更好的用户体验，减轻服务器的压力，实现缓存后的步骤:</p><ol><li>先判断是否有缓存数据，如果有先加载缓存数据</li><li>判断有没有网络</li><li>没网,结束.</li><li>有网，继续请求，刷新数据，将服务器的数据缓存到硬盘</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>在iOS中，苹果已经为我们提供了<strong>NSURLCache</strong>类来实现缓存</p><p>但是这里我并没有使用苹果提供的，而是第三方<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>来实现对网络请求的缓存</p><p>使用<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>进行网络请求管理</p><ul><li>对GET请求进行缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 发送 GET 请求</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *   GET请求</span><br><span class="line"> *</span><br><span class="line"> *   @param url           url</span><br><span class="line"> *   @param params        请求的参数字典</span><br><span class="line"> *   @param cache         是否缓存</span><br><span class="line"> *   @param successBlock  成功的回调</span><br><span class="line"> *   @param failureBlock  失败的回调</span><br><span class="line"> *   @param showHUD       是否加载进度指示器</span><br><span class="line"> */</span><br><span class="line">+ (NSURLSessionTask *)getRequestWithUrl:(NSString *)url</span><br><span class="line">                                 params:(NSDictionary *)params</span><br><span class="line">                                  cache:(BOOL)isCache</span><br><span class="line">                           successBlock:(QCSuccessBlock)successBlock</span><br><span class="line">                           failureBlock:(QCFailureBlock)failureBlock</span><br><span class="line">                                showHUD:(BOOL)showHUD&#123;</span><br><span class="line">    </span><br><span class="line">    __block NSURLSessionTask *session = nil;</span><br><span class="line"></span><br><span class="line">    if (isCache) &#123;</span><br><span class="line">        </span><br><span class="line">        id responseObject = [QCNetworkCache getCacheResponseObjectWithRequestUrl:url params:params];</span><br><span class="line">        </span><br><span class="line">        if (responseObject) &#123;</span><br><span class="line">            </span><br><span class="line">            int code = 0;</span><br><span class="line">            NSString *msg = nil;</span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                //这个字段取决于 服务器</span><br><span class="line">                code                = [responseObject[@&quot;rsCode&quot;] intValue];</span><br><span class="line">                msg                 = responseObject[@&quot;rsMsg&quot;];</span><br><span class="line">            &#125;</span><br><span class="line">            successBlock ? successBlock(responseObject, code, msg) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //没有网络直接返回</span><br><span class="line">    if (networkStatus == QCNetworkStatusNotReachable) &#123;</span><br><span class="line">        failureBlock ? failureBlock(QC_ERROR) : 0;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(showHUD) NSLog(@&quot;加载中&quot;);</span><br><span class="line"></span><br><span class="line">    session = [_manager GET:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line"></span><br><span class="line">        int code = 0;</span><br><span class="line">        NSString *msg = nil;</span><br><span class="line">        </span><br><span class="line">        if (responseObject) &#123;</span><br><span class="line">            //这个字段取决于 服务器</span><br><span class="line">            code                = [responseObject[@&quot;rsCode&quot;] intValue];</span><br><span class="line">            msg                 = responseObject[@&quot;rsMsg&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        successBlock ? successBlock(responseObject, code, msg) : 0;</span><br><span class="line">        </span><br><span class="line">        //缓存数据</span><br><span class="line">        isCache ? [QCNetworkCache cacheResponseObject:responseObject requestUrl:url params:params] : 0;</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line">        failureBlock ? failureBlock(error) : 0;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [session resume];</span><br><span class="line">    </span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存缓存具体实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  对请求进行缓存</span><br><span class="line"> *</span><br><span class="line"> *  @param responseObject 需要缓存的数据</span><br><span class="line"> *  @param requestUrl     请求url</span><br><span class="line"> *  @param params         参数</span><br><span class="line"> */</span><br><span class="line">+ (void)cacheResponseObject:(id)responseObject</span><br><span class="line">                 requestUrl:(NSString *)requestUrl</span><br><span class="line">                     params:(NSDictionary *)params&#123;</span><br><span class="line">    assert(responseObject);</span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    if (!params) params = @&#123;&#125;;</span><br><span class="line">    NSString *originString = [NSString stringWithFormat:@&quot;%@-%@&quot;,requestUrl,params];</span><br><span class="line">    NSString *hash = [self md5:originString];</span><br><span class="line">    </span><br><span class="line">    [cache setObject:responseObject forKey:hash withBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;成功 hash = %@&quot;, hash);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取已缓存的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  获取已缓存的请求</span><br><span class="line"> *</span><br><span class="line"> *  @param requestUrl 请求地址</span><br><span class="line"> *  @param params     参数</span><br><span class="line"> *</span><br><span class="line"> *  @return 缓存的数据</span><br><span class="line"> */</span><br><span class="line"> + (id)getCacheResponseObjectWithRequestUrl:(NSString *)requestUrl</span><br><span class="line">                                    params:(NSDictionary *)params&#123;</span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    if (!params) params = @&#123;&#125;;</span><br><span class="line">    NSString *originString = [NSString stringWithFormat:@&quot;%@-%@&quot;,requestUrl,params];</span><br><span class="line">    NSString *hash = [self md5:originString];</span><br><span class="line">    </span><br><span class="line">    id cacheData = [cache objectForKey:hash];</span><br><span class="line">    </span><br><span class="line">    return cacheData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对下载请求进行缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 文件下载</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  文件下载 (带缓存)</span><br><span class="line"> *</span><br><span class="line"> *  @param url           下载文件接口地址</span><br><span class="line"> *  @param progressBlock 下载进度</span><br><span class="line"> *  @param successBlock  成功回调</span><br><span class="line"> *  @param failBlock     下载回调</span><br><span class="line"> *  @param showHUD       是否加载进度指示器</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求</span><br><span class="line"> */</span><br><span class="line">+ (NSURLSessionTask *)downloadWithUrl:(NSString *)url</span><br><span class="line">                        progressBlock:(QCProgressBlock)progressBlock</span><br><span class="line">                         successBlock:(QCDownloadSuccessBlock)successBlock</span><br><span class="line">                         failureBlock:(QCFailureBlock)failureBlock</span><br><span class="line">                              showHUD:(BOOL)showHUD&#123;</span><br><span class="line">    </span><br><span class="line">    __block NSURLSessionTask *session = nil;</span><br><span class="line">    </span><br><span class="line">    NSString *type = nil;</span><br><span class="line">    NSArray *subStringArr = nil;</span><br><span class="line">    </span><br><span class="line">    NSURL *fileUrl = [QCNetworkCache getDownloadDataFromCacheWithRequestUrl:url];</span><br><span class="line">    </span><br><span class="line">    if (fileUrl) &#123;</span><br><span class="line">        if (successBlock) successBlock(fileUrl);</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //没有网络直接返回</span><br><span class="line">    if (networkStatus == QCNetworkStatusNotReachable) &#123;</span><br><span class="line">        failureBlock ? failureBlock(QC_ERROR) : 0;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(showHUD) NSLog(@&quot;加载中&quot;);</span><br><span class="line">    </span><br><span class="line">    if (url) &#123;</span><br><span class="line">        subStringArr = [url componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">        if (subStringArr.count &gt; 0) &#123;</span><br><span class="line">            type = subStringArr[subStringArr.count - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //响应内容序列化为二进制</span><br><span class="line">    _manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    session = [_manager GET:url parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        </span><br><span class="line">        progressBlock ? progressBlock((float)downloadProgress.completedUnitCount/(float)downloadProgress.totalUnitCount) : 0;</span><br><span class="line"></span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line">        </span><br><span class="line">        if (successBlock) &#123;</span><br><span class="line">            NSData *data = (NSData *)responseObject;</span><br><span class="line">            </span><br><span class="line">            [QCNetworkCache saveDownloadData:data requestUrl:url];</span><br><span class="line">            </span><br><span class="line">            NSURL *downFileUrl = [QCNetworkCache getDownloadDataFromCacheWithRequestUrl:url];</span><br><span class="line">            </span><br><span class="line">            successBlock(downFileUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line">        </span><br><span class="line">        failureBlock ? failureBlock(error) : 0;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [session resume];</span><br><span class="line">    </span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对下载的数据进行缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  对下载的数据进行缓存</span><br><span class="line"> *</span><br><span class="line"> *  @param data       下载的数据</span><br><span class="line"> *  @param requestUrl 请求url</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> + (void)saveDownloadData:(NSData *)data</span><br><span class="line">              requestUrl:(NSString *)requestUrl &#123;</span><br><span class="line">    assert(data);</span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    NSString *fileName = nil;</span><br><span class="line">    NSString *type = nil;</span><br><span class="line">    NSArray *strArray = nil;</span><br><span class="line">    </span><br><span class="line">    strArray = [requestUrl componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">    if (strArray.count &gt; 0) &#123;</span><br><span class="line">        type = strArray[strArray.count - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (type) &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@.%@&quot;,[self md5:requestUrl],type];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@&quot;,[self md5:requestUrl]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *directoryPath = nil;</span><br><span class="line">    directoryPath = [[NSUserDefaults standardUserDefaults] objectForKey:downloadDirKey];</span><br><span class="line">    if (!directoryPath) &#123;</span><br><span class="line">        directoryPath = [[[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] stringByAppendingPathComponent:@&quot;QCNetworking&quot;] stringByAppendingPathComponent:@&quot;download&quot;];</span><br><span class="line">        </span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setObject:directoryPath forKey:downloadDirKey];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:directoryPath isDirectory:nil]) &#123;</span><br><span class="line">        [[NSFileManager defaultManager] createDirectoryAtPath:directoryPath withIntermediateDirectories:YES attributes:nil error:&amp;error];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;创建目录错误: %@&quot;,error.localizedDescription);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [directoryPath stringByAppendingPathComponent:fileName];</span><br><span class="line">    </span><br><span class="line">    [[NSFileManager defaultManager] createFileAtPath:filePath contents:data attributes:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取已缓存的下载数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  获取已缓存的下载数据</span><br><span class="line"> *</span><br><span class="line"> *  @param requestUrl 请求url</span><br><span class="line"> *</span><br><span class="line"> *  @return 缓存的url路径</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> + (NSURL *)getDownloadDataFromCacheWithRequestUrl:(NSString *)requestUrl &#123;</span><br><span class="line">    </span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    NSString *fileName = nil;</span><br><span class="line">    NSString *type = nil;</span><br><span class="line">    NSArray *strArray = nil;</span><br><span class="line">    NSURL *fileUrl = nil;</span><br><span class="line">    </span><br><span class="line">    strArray = [requestUrl componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">    if (strArray.count &gt; 0) &#123;</span><br><span class="line">        type = strArray[strArray.count - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (type) &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@.%@&quot;,[self md5:requestUrl],type];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@&quot;,[self md5:requestUrl]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSString *directoryPath = [[NSUserDefaults standardUserDefaults] objectForKey:downloadDirKey];</span><br><span class="line">    </span><br><span class="line">    if (directoryPath)&#123;</span><br><span class="line">        NSString *filePath = [directoryPath stringByAppendingPathComponent:fileName];</span><br><span class="line">        data = [[NSFileManager defaultManager] contentsAtPath:filePath];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (data) &#123;</span><br><span class="line">        NSString *path = [directoryPath stringByAppendingPathComponent:fileName];</span><br><span class="line">        fileUrl = [NSURL fileURLWithPath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return fileUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体代码实现Github"><a href="#具体代码实现Github" class="headerlink" title="具体代码实现Github"></a>具体代码实现<a href="https://github.com/Joe0708/QCNetworking" target="_blank" rel="noopener">Github</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;p&gt;在开发中我们常常需要向服务器发送请求来获得数据, 正常的流程是这样:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送请求&lt;/li&gt;
&lt;li&gt;网络正常, 将数
      
    
    </summary>
    
      <category term="iOS" scheme="http://aidevjoe.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://aidevjoe.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://aidevjoe.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 性能优化</title>
    <link href="http://aidevjoe.github.io/2016/09/12/UITableView-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://aidevjoe.github.io/2016/09/12/UITableView-性能优化/</id>
    <published>2016-09-12T03:37:59.000Z</published>
    <updated>2018-11-25T09:10:23.626Z</updated>
    
    <content type="html"><![CDATA[<p>UITableView是iOS中使用最频繁的控件之一，平常使用过程中我们往往不会注意到其性能优化问题，只有当视图逻辑层次越来越复杂的时候，会导致列表的滑动不是那么流畅, 所有其性能优化也是常常要面对的，尤其是当数据量偏大并且设备性能不足时。那么当我们遇到这个问题时该如何下手呢，本篇文章主要总结和介绍UITableView的性能优化方法，其中一些优化方式是作者在开发中使用过的，有些是总结前人经验，在此总结UITableView的几个性能优化方式</p><h3 id="首先我们分析总结一些影响UITableView性能的几个因素"><a href="#首先我们分析总结一些影响UITableView性能的几个因素" class="headerlink" title="首先我们分析总结一些影响UITableView性能的几个因素:"></a>首先我们分析总结一些影响UITableView性能的几个因素:</h3><ol><li>多种类型cell及过于复杂的视图层级</li><li>cell的高度动态计算</li><li>离屏渲染</li><li>按需加载</li><li>…</li></ol><h4 id="1-视图层级过于复杂"><a href="#1-视图层级过于复杂" class="headerlink" title="1.视图层级过于复杂"></a>1.视图层级过于复杂</h4><p>   由于APP业务越来越复杂分析Cell结构，TableView的视图层级可能越来越复杂，我们可能会用多个cell以应对我们的需求，但是这样也是导致性能下降的原因，所有我们尽可能的将相同内容的抽取到一种样式Cell中，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。好处：</p><blockquote><p>减少代码量，减少Nib文件的数量，统一一个Nib文件定义Cell，容易修改、维护</p></blockquote><p>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为N个。所以如果如果只有一种Cell，那就是只有N个Cell的实例；但是如果有M种Cell，那么运行时最多可能会是“M x N = MN”个Cell的实例，虽然可能并不会占用太多内存，但是能少点不是更好吗。</p><p>，导致性能出现问题，我们在分析cell时，尽量去避免remove、addSubviews 视图, 而是根据逻辑设置视图的hidden隐藏(显示)。在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建、删除要快得多。</p><h4 id="2-cell的高度动态计算"><a href="#2-cell的高度动态计算" class="headerlink" title="2.cell的高度动态计算"></a>2.cell的高度动态计算</h4><p>当cell的每一个cell的高度一样时, 我们可以通过简单的一行代码解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.rowHeight = 88;</span><br></pre></td></tr></table></figure><p>但是如果我们每个cell的高度不一样时, 这时候就需要实现代理方法根据数据返回不一样的高度, 需要注意的是，实现了这个方法后，rowHeight的设置将无效。所以，这个方法适用于具有多种cell高度的UITableView, 行高一样的情况建议你使用前者性能更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    // return xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样我们cell将要出现在屏幕的时候，系统都会去计算cell的高度。导致性能低下，如果说我能通过某种手段，在首次计算的时候，将每个cell对应的高度保存下载，当下次需要用到cell高度的时候再从保存的地方取出，从而减少了计算量，来达到优化的目的。<br>因此应运而生了这套高度缓存的算法的第三方库<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView-FDTemplateLayoutCell</a></p><p>通过第三库在 tableView: heightForRowAtIndexPath: 代理方法中调用以下三个方法之一完成高度获取，从而提高APP性能：*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   identifier 即 cell 的 identifier；</span><br><span class="line">   configuration block 中的代码应与数据源方法 tableView: cellForRowAtIndexPath: 中对 cell 的设置代码相同</span><br><span class="line">   方法内部将根据以上两个参数创建与 cell 对应的 template layout cell，这个 cell 只进行高度计算，不会显示到屏幕上</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 返回计算好的高度(无缓存)</span><br><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifierconfiguration:(void (^)(idcell))configuration;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 返回计算好的高度，并根据 indexPath 内部创建与之相应的二维数组缓存高度</span><br><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifiercacheByIndexPath:(NSIndexPath *)indexPathconfiguration:(void (^)(idcell))configuration;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 返回计算好的高度，内部创建一个字典缓存高度并由使用者指定 key</span><br><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifiercacheByKey:(id&lt;NSCopying&gt;)keyconfiguration:(void (^)(idcell))configuration;</span><br></pre></td></tr></table></figure><h3 id="3-离屏渲染"><a href="#3-离屏渲染" class="headerlink" title="3.离屏渲染"></a>3.离屏渲染</h3><h4 id="GPU渲染机制："><a href="#GPU渲染机制：" class="headerlink" title="GPU渲染机制："></a>GPU渲染机制：</h4><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><h4 id="GPU屏幕渲染有以下两种方式："><a href="#GPU屏幕渲染有以下两种方式：" class="headerlink" title="GPU屏幕渲染有以下两种方式："></a>GPU屏幕渲染有以下两种方式：</h4><ol><li>On-Screen Rendering  意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li><li>Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<blockquote><p>  离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。</p></blockquote></li></ol><h4 id="离屏渲染的触发方式"><a href="#离屏渲染的触发方式" class="headerlink" title="离屏渲染的触发方式"></a>离屏渲染的触发方式</h4><p>设置了以下属性时，都会触发离屏绘</p><ol><li>cornerRadius (圆角）</li><li>masks（遮罩）</li><li>shadows（阴影）</li><li>group opacity（不透明）</li><li>…</li></ol><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换，不管是在GPU渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到On-Screen Rendering或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次mask的渲染操作。</p><p>一次mask发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次mask需要渲染三次才能在屏幕上显示，这已经是普通视图显示3陪耗时，若再加上下文环境切换，一次mask就是普通渲染的30倍以上耗时操作。问我这个30倍以上这个数据怎么的出来的？当我在cell的UIImageView的实例增加到150个，并去掉圆角的时候，帧数才跌至28帧每秒。虽然不是甚准确，但至少反映mask这个耗时是无mask操作的耗时的数十倍的。</p><p>那么如何应对这个问题呢？不要在滚动视图使用cornerRadius或者mask。如果你一定要怎么办呢？那么这样也可以拯救你：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.layer.shouldRasterize = YES;  </span><br><span class="line"></span><br><span class="line">self.layer.rasterizationScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure><p>这样大部分情况下可以马上挽救你的帧数在55帧每秒以上。shouldRasterize = YES会使视图渲染内容被缓存起来，下次绘制的时候可以直接显示缓存，当然要在视图内容不改变的情况下，对于复制的视图层次并不建议你这样做。</p><p>还是采取预先生成圆角图片，并缓存起来这个方法才是比较好的手段。预处理圆角图片可以在后台处理，处理完毕后缓存起来，再在主线程显示，这就避免了不必要的离屏渲染了。</p><p>另外也有在图片上面覆盖一个镂空圆形图片的方法可以实现圆形头像效果，这个也是极为高效的方法。缺点就是对视图的背景有要求，单色背景效果就最为理想。</p><h4 id="4-按需加载"><a href="#4-按需加载" class="headerlink" title="4.按需加载"></a>4.按需加载</h4><p>   开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</span><br><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</span><br></pre></td></tr></table></figure><p>   思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     //获取可见部分的Cell</span><br><span class="line">NSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];</span><br><span class="line">        for (NSIndexPath *indexPath in visiblePaths)</span><br><span class="line">        &#123;</span><br><span class="line">        //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载</span><br><span class="line">             &lt;code&gt;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// tableView 停止滑动的时候异步加载图片</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">         if (self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO)</span><br><span class="line">            &#123;</span><br><span class="line">               //开始异步加载图片</span><br><span class="line">                &lt;code&gt;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="最后对性能优化的几点建议"><a href="#最后对性能优化的几点建议" class="headerlink" title="最后对性能优化的几点建议"></a>最后对性能优化的几点建议</h4><ul><li>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；(这个是开发中肯定会要优化的，不可能一个app就几个Cell吧)</li><li>滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage</li><li>异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）</li><li>缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向</li><li>“真机测试，而不是模拟器”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UITableView是iOS中使用最频繁的控件之一，平常使用过程中我们往往不会注意到其性能优化问题，只有当视图逻辑层次越来越复杂的时候，会导致列表的滑动不是那么流畅, 所有其性能优化也是常常要面对的，尤其是当数据量偏大并且设备性能不足时。那么当我们遇到这个问题时该如何下手
      
    
    </summary>
    
      <category term="iOS" scheme="http://aidevjoe.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://aidevjoe.github.io/tags/iOS/"/>
    
      <category term="UITableView" scheme="http://aidevjoe.github.io/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS中几种数据持久化的方案</title>
    <link href="http://aidevjoe.github.io/2016/09/09/iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>http://aidevjoe.github.io/2016/09/09/iOS中几种数据持久化的方案/</id>
    <published>2016-09-09T06:45:28.000Z</published>
    <updated>2018-11-25T09:10:16.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我将尝试着介绍一下5种方案：</p><ul><li>plist文件（属性列表）</li><li>preference（偏好设置）</li><li>NSKeyedArchiver（归档）</li><li>SQLite 3</li><li>CoreData</li></ul><p><img src="https://ws1.sinaimg.cn/large/ed35dd08gy1fxkb61mv1rj20ce0970t1.jpg" alt=""></p><h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p><font color="#c10d0c" size="3">1.结构</font><p>既然沙盒就是一个文件夹，那就看看里面有什么吧。沙盒的目录结构如下：</p><ol><li>“应用程序包”</li><li>Documents</li><li>Library</li><li>——-Caches</li><li>——-Preferences</li><li>tmp</li></ol><font color="#c10d0c" size="3">2.目录特性</font><p>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p><p>“应用程序包”: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] bundlePath];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p>Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p> Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line"> NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p>  Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p><p>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSTemporaryDirectory();</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p>  <br><br>  <font color="#0099ff" size="3">plist文件</font></p><p>  plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p><p>可以被序列化的类型只有如下几种：</p><ol><li>NSArray</li><li>NSMutableArray</li><li>NSDictionary</li><li>NSMutableDictionary</li><li>NSData</li><li>NSMutableData</li><li>NSString</li><li>NSMutableString</li><li>NSNumber</li><li>NSDate</li></ol><font color="#c10d0c" size="3">1.获得文件路径</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line">   NSString *fileName = [path stringByAppendingPathComponent:@&quot;123.plist&quot;];</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">2.存储</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;123&quot;, @&quot;456&quot;, @&quot;789&quot;];</span><br><span class="line">[array writeToFile:fileName atomically:YES];</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">3.读取</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *result = [NSArray arrayWithContentsOfFile:fileName];</span><br><span class="line">NSLog(@&quot;%@&quot;, result);</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">4.注意</font><ul><li>只有以上列出的类型才能使用plist文件存储。</li><li>存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。</li><li>读取时使用arrayWithContentsOfFile:方法。</li></ul><p><br></p><font color="#0099ff" size="3">Preference</font><br><br><br><br><br><font color="#c10d0c" size="3">1.使用方法</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1.获得NSUserDefaults文件</span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">//2.向文件中写入内容</span><br><span class="line">[userDefaults setObject:@&quot;AAA&quot; forKey:@&quot;a&quot;];</span><br><span class="line">[userDefaults setBool:YES forKey:@&quot;sex&quot;];</span><br><span class="line">[userDefaults setInteger:21 forKey:@&quot;age&quot;];</span><br><span class="line">//2.1立即同步</span><br><span class="line">[userDefaults synchronize];</span><br><span class="line">//3.读取文件</span><br><span class="line">NSString *name = [userDefaults objectForKey:@&quot;a&quot;];</span><br><span class="line">BOOL sex = [userDefaults boolForKey:@&quot;sex&quot;];</span><br><span class="line">NSInteger age = [userDefaults integerForKey:@&quot;age&quot;];</span><br><span class="line">NSLog(@&quot;%@, %d, %ld&quot;, name, sex, age);</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">2.注意</font><ul><li>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。 </li><li>如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。</li><li>偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</li></ul><p><br></p><font color="#0099ff" size="3">NSKeyedArchiver</font><p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p><font color="#c10d0c" size="3">1.遵循NSCoding协议</font><p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p><ul><li>遵循协议和设置属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.遵循NSCoding协议 </span><br><span class="line">@interface Person : NSObject   //2.设置属性</span><br><span class="line">@property (strong, nonatomic) UIImage *avatar;</span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line">@property (assign, nonatomic) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>实现协议方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  //解档</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if ([super init]) &#123;</span><br><span class="line">        self.avatar = [aDecoder decodeObjectForKey:@&quot;avatar&quot;];</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">        self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//归档</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:self.avatar forKey:@&quot;avatar&quot;];</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>特别注意</p><p>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 <strong>[super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder]</strong> 方法;</p></li></ul><font color="#c10d0c" size="3">2.使用</font><p>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.avatar = self.avatarView.image;</span><br><span class="line">person.name = self.nameField.text;</span><br><span class="line">person.age = [self.ageField.text integerValue];</span><br><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:file];</span><br></pre></td></tr></table></figure><p>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];</span><br><span class="line">if (person) &#123;</span><br><span class="line">   self.avatarView.image = person.avatar;</span><br><span class="line">   self.nameField.text = person.name;</span><br><span class="line">   self.ageField.text = [NSString stringWithFormat:@&quot;%ld&quot;, person.age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">3.注意</font><ul><li>必须遵循并实现NSCoding协议</li><li>保存文件的扩展名可以任意指定</li><li>继承时必须先调用父类的归档解档方法</li></ul><p><br></p><font color="#0099ff" size="3">SQLite3</font><p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p><font color="#c10d0c" size="3">1.字段类型</font><p>表面上SQLite将数据分为以下几种类型：</p><ul><li>integer : 整数</li><li>real : 实数（浮点数）</li><li>text : 文本字符串</li><li>blob : 二进制数据，比如文件，图片之类的</li></ul><p>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！<strong>主键必须设置成integer</strong></p><font color="#c10d0c" size="3">2. 准备工作</font><p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p><font color="#c10d0c" size="3">3.使用</font><ul><li>创建数据库并打开</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  打开数据库并创建一个表</span><br><span class="line">*/</span><br><span class="line">- (void)openDatabase &#123;</span><br><span class="line">   //1.设置文件名</span><br><span class="line">   NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span><br><span class="line">   //2.打开数据库文件，如果没有会自动创建一个文件</span><br><span class="line">   NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</span><br><span class="line">   if (result == SQLITE_OK) &#123;</span><br><span class="line">       NSLog(@&quot;打开数据库成功！&quot;);</span><br><span class="line">       //3.创建一个数据库表</span><br><span class="line">       char *errmsg = NULL;</span><br><span class="line">       sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">       if (errmsg) &#123;</span><br><span class="line">           NSLog(@&quot;错误：%s&quot;, errmsg);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           NSLog(@&quot;创表成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       NSLog(@&quot;打开数据库失败！&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行指令</li></ul><p>使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  往表中插入1000条数据</span><br><span class="line">*/</span><br><span class="line">- (void)insertData &#123;</span><br><span class="line">NSString *nameStr;</span><br><span class="line">NSInteger age;</span><br><span class="line">for (NSInteger i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  nameStr = [NSString stringWithFormat:@&quot;Bourne-%d&quot;, arc4random_uniform(10000)];</span><br><span class="line">  age = arc4random_uniform(80) + 20;</span><br><span class="line">  NSString *sql = [NSString stringWithFormat:@&quot;INSERT INTO t_person (name, age) VALUES(&apos;%@&apos;, &apos;%ld&apos;)&quot;, nameStr, age];</span><br><span class="line">  char *errmsg = NULL;</span><br><span class="line">  sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg);</span><br><span class="line">  if (errmsg) &#123;</span><br><span class="line">      NSLog(@&quot;错误：%s&quot;, errmsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;插入完毕！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询指令</li></ul><p>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p><ol><li>sqlite3_prepare_v2() : 检查sql的合法性</li><li>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</li><li>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</li><li>sqlite3_finalize() : 释放stmt</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  从表中读取数据到数组中</span><br><span class="line">*/</span><br><span class="line">- (void)readData &#123;</span><br><span class="line">   NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000];</span><br><span class="line">   char *sql = &quot;select name, age from t_person;&quot;;</span><br><span class="line">   sqlite3_stmt *stmt;</span><br><span class="line">   NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL);</span><br><span class="line">   if (result == SQLITE_OK) &#123;</span><br><span class="line">       while (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">           char *name = (char *)sqlite3_column_text(stmt, 0);</span><br><span class="line">           NSInteger age = sqlite3_column_int(stmt, 1);</span><br><span class="line">           //创建对象</span><br><span class="line">           Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age];</span><br><span class="line">           [mArray addObject:person];</span><br><span class="line">       &#125;</span><br><span class="line">       self.dataList = mArray;</span><br><span class="line">   &#125;</span><br><span class="line">   sqlite3_finalize(stmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">4.总结</font><p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p><p><br></p><font color="#0099ff" size="3">FMDB</font><br><br><br><br><br><font color="#c10d0c" size="3">1.简介</font><p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p><ul><li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li><li>对比苹果自带的Core Data框架，更加轻量级和灵活</li><li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li><li>注：<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB的gitHub地址</a></li></ul><font color="#c10d0c" size="3">2.核心类</font><p>FMDB有三个主要的类：</p><ul><li>FMDatabase</li></ul><p>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p><ul><li>FMResultSet</li></ul><p>使用FMDatabase执行查询后的结果集</p><ul><li>FMDatabaseQueue</li></ul><p>用于在多线程中执行多个查询或更新，它是线程安全的</p><font color="#c10d0c" size="3">3.打开数据库</font><p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span><br><span class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </span><br><span class="line">if (![database open]) &#123;</span><br><span class="line">    NSLog(@&quot;数据库打开失败！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，Path的值可以传入以下三种情况：</p><ul><li>具体文件路径，如果不存在会自动创建</li><li>空字符串@””，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li><li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li></ul><font color="#c10d0c" size="3">4.更新</font><p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//常用方法有以下3种：   </span><br><span class="line">- (BOOL)executeUpdate:(NSString*)sql, ...</span><br><span class="line">- (BOOL)executeUpdateWithFormat:(NSString*)format, ...</span><br><span class="line">- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments</span><br><span class="line">//示例</span><br><span class="line">[database executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;];   </span><br><span class="line">//或者  </span><br><span class="line">[database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES(?, ?)&quot;, @&quot;Bourne&quot;, [NSNumber numberWithInt:42]];</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">5.查询</font><p>查询方法也有3种，使用起来相当简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(NSString*)sql, ...</span><br><span class="line">- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</span><br><span class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</span><br></pre></td></tr></table></figure><p>查询示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.执行查询</span><br><span class="line">FMResultSet *result = [database executeQuery:@&quot;SELECT * FROM t_person&quot;];</span><br><span class="line">//2.遍历结果集</span><br><span class="line">while ([result next]) &#123;</span><br><span class="line">    NSString *name = [result stringForColumn:@&quot;name&quot;];</span><br><span class="line">    int age = [result intForColumn:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">6.线程安全</font><p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p><ul><li>创建队列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</span><br></pre></td></tr></table></figure><ul><li>使用队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_1&quot;, [NSNumber numberWithInt:1]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_2&quot;, [NSNumber numberWithInt:2]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_3&quot;, [NSNumber numberWithInt:3]];      </span><br><span class="line">          FMResultSet *result = [database executeQuery:@&quot;select * from t_person&quot;];    </span><br><span class="line">         while([result next]) &#123;   </span><br><span class="line">         &#125;    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>而且可以轻松地把简单任务包装到事务里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *database, BOOL *rollback) &#123;    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_1&quot;, [NSNumber numberWithInt:1]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_2&quot;, [NSNumber numberWithInt:2]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_3&quot;, [NSNumber numberWithInt:3]];      </span><br><span class="line">          FMResultSet *result = [database executeQuery:@&quot;select * from t_person&quot;];    </span><br><span class="line">             while([result next]) &#123;   </span><br><span class="line">             &#125;   </span><br><span class="line">           //回滚</span><br><span class="line">           *rollback = YES;  </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; class=&quot;headerlink&quot; title=&quot;概论&quot;&gt;&lt;/a&gt;概论&lt;/h2&gt;&lt;p&gt;所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我
      
    
    </summary>
    
      <category term="iOS" scheme="http://aidevjoe.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://aidevjoe.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
