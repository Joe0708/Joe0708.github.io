<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe</title>
  
  <subtitle>Joe</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://joe0708.github.io/"/>
  <updated>2018-01-14T10:47:26.000Z</updated>
  <id>http://joe0708.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://joe0708.github.io/2018/01/14/hello-world/"/>
    <id>http://joe0708.github.io/2018/01/14/hello-world/</id>
    <published>2018-01-14T09:33:33.000Z</published>
    <updated>2018-01-14T10:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在 macOS 上更优雅的使用答题辅助脚本</title>
    <link href="http://joe0708.github.io/2018/01/13/DaTiFuZhu/"/>
    <id>http://joe0708.github.io/2018/01/13/DaTiFuZhu/</id>
    <published>2018-01-13T07:29:57.000Z</published>
    <updated>2018-01-14T16:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Joe0708/TopSup-for-iOS" target="_blank" rel="noopener">Github 链接</a></p><p>在 macOS 上更优雅的使用答题辅助脚本, 基于 <a href="https://github.com/Skyexu/TopSup" target="_blank" rel="noopener">TopSup</a> 修改，删除了安卓平台相关代码</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Mac 和 iOS 双平台虽然可以使用 <a href="https://github.com/facebook/WebDriverAgent" target="_blank" rel="noopener">WDA</a> 来到达获取屏幕当前截图的目的，但是经体验 WDA 不仅安装非常多坑，譬如获取不到 ip、证书 或 端口转发 等问题，而且在 iPhone X 机型上经常无故断开，导致无法获取截图。基于这种情况所有想到了那外一种解决方案，利用 <strong>QuickTime</strong>。这里仅仅提供一种思路，可以参考后然后基于原仓库修改。</p><h2 id="概况"><a href="#概况" class="headerlink" title="概况:"></a>概况:</h2><ol><li>利用 QuickTime(或 AirServer 其他方案) 将 iPhone 投屏到 Mac 上</li><li>利用 macOS 自带的 <strong>screencapture</strong> 命令截图图片</li><li>利用原脚本完成剩余操作</li></ol><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h4 id="一、-利用-QuickTime-或-AirServer-其他方案-将-iPhone-投屏到-Mac-上"><a href="#一、-利用-QuickTime-或-AirServer-其他方案-将-iPhone-投屏到-Mac-上" class="headerlink" title="一、 利用 QuickTime(或 AirServer 其他方案) 将 iPhone 投屏到 Mac 上"></a>一、 利用 QuickTime(或 AirServer 其他方案) 将 iPhone 投屏到 Mac 上</h4><p>打开 <strong>QuickTime Player.app</strong>， 点击菜单栏-&gt;文件-&gt;新建影片录制, 点击录制按钮旁边的小箭头，选择你的 iPhone 即可，<a href="https://jingyan.baidu.com/article/59703552e714e48fc007402d.html" target="_blank" rel="noopener">具体教程</a></p><p><img src="http://ojpb4w81b.bkt.clouddn.com/18-1-12/84684463.jpg" alt=""></p><h4 id="二、利用-macOS-自带-screencapture-命令截图图片"><a href="#二、利用-macOS-自带-screencapture-命令截图图片" class="headerlink" title="二、利用 macOS 自带 screencapture 命令截图图片"></a>二、利用 macOS 自带 screencapture 命令截图图片</h4><p><strong>macOS</strong> 中内置了一个截图命令，既 <strong>screencapture</strong>，可通过 <code>screencapture --help</code> 查看帮助，其中有个 <strong>-R</strong> 参数可以指定截图区域，既 x,y,w,h。用过该命令获取 问题 和 答案选项 区域的截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screencapture -R&quot;20,190,310,100&quot; ./question_screenshot.png</span><br></pre></td></tr></table></figure><p>通过 <strong>Python</strong> os 模块中的 system 来调用 <strong>shell</strong> 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.system(&quot;screencapture -R\&quot;20,190,310,100\&quot; ./question_screenshot.png&quot;)</span><br></pre></td></tr></table></figure><h4 id="三、参考原脚本说明-配置-安装-ocr-及相应库即可"><a href="#三、参考原脚本说明-配置-安装-ocr-及相应库即可" class="headerlink" title="三、参考原脚本说明 配置/安装 ocr 及相应库即可"></a>三、参考<a href="https://github.com/Skyexu/TopSup" target="_blank" rel="noopener">原脚本说明</a> 配置/安装 ocr 及相应库即可</h4><p>参考<a href="https://github.com/Skyexu/TopSup" target="_blank" rel="noopener">原脚本说明</a> 配置/安装 ocr 及相应库。</p><p>参考 <strong>getQuestionAnswer.py</strong> 删除 WDA 相关代码，修改自己的坐标值，建议将 QuickTime 的窗口缩小再测量。</p><p>⚠️ 此 Demo 不会保持与原仓库的更新，仅供参考思路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Joe0708/TopSup-for-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 macOS 上更优雅的使用答题辅助脚本, 基于 &lt;a href
      
    
    </summary>
    
      <category term="Python" scheme="http://joe0708.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://joe0708.github.io/tags/Python/"/>
    
      <category term="脚本" scheme="http://joe0708.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Vim 复习笔记</title>
    <link href="http://joe0708.github.io/2018/01/05/Vim-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://joe0708.github.io/2018/01/05/Vim-复习笔记/</id>
    <published>2018-01-05T14:57:26.000Z</published>
    <updated>2018-01-14T16:59:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换模式"><a href="#切换模式" class="headerlink" title="切换模式"></a>切换模式</h3><ul><li>esc 进入命令模式</li><li>: 进入末尾模式</li></ul><h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><ul><li>i 光标前插入文本</li><li>I 行首插入文本</li><li>a 光标后插入文本 </li><li>A 行尾插入文本</li><li>o 下一行插入文本</li><li>O 上一行插入文本</li></ul><h3 id="复制粘贴删除"><a href="#复制粘贴删除" class="headerlink" title="复制粘贴删除"></a>复制粘贴删除</h3><ul><li>yy 复制光标所在行</li><li>4yy 光标所在行向下复制4行 </li><li>p 光标处粘贴</li><li>dd 删除/剪切 光标所在行</li><li>4dd 光标所在行向下 删除/剪切 4行</li><li>D 从当前光标处开始删除, 直到行尾</li><li>d0 从当前光标处开始删除, 直到行首 </li><li>u 撤销上一个操作</li><li>Ctrl+r 反撤销</li><li>x 删除光标处单个字符</li><li>X 删除光标处前一个字符</li><li>dw 删除光标所在的整个单词</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>r 替换光标处所选字符</li><li>R 替换光标处以后面的所有字符</li><li>:$s/hello/word/g 进入末尾模式并将所有的 hello 替换为 word</li><li>:10,20s/hello/word/g 进入末尾模式并 第10行直第20行之间将所有的 hello 替换为 word</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>/hello 进入查找模式, 并搜索 hello<br>a 下一个匹配处<br>A 上一个匹配处</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li>j 下</li><li>k 上</li><li>h 左</li><li>l 右</li><li>M 回到当前屏幕中间</li><li>H 回到当前屏幕上方</li><li>L 回到当前屏幕下方</li><li>Ctrl+f 向下翻一页</li><li>Ctrl+b 向上翻一页</li><li>Ctrl+u 向上翻半页</li><li>Ctrl+d 向下翻半页</li><li>11G 光标定位到第11行</li><li>Ctrl+G 回到文档底部</li><li>gg 回到文档顶部</li><li>w 跳到下一个单词的开始处</li><li>b 跳到上一个单词的开始处</li><li>{ 跳到上一段文本的开头</li><li>} 跳到下一段文本的尾部</li></ul><h3 id="选中操作"><a href="#选中操作" class="headerlink" title="选中操作"></a>选中操作</h3><ul><li>v 选中文本, 按字符移动</li><li>V 选中整行文本, 按行移动</li><li>&lt;&lt; 向左移动文本</li><li><blockquote><blockquote><p>向右移动文本</p></blockquote></blockquote></li><li>. 重复执行上一次操作</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>shift+zz 保存并退出 相当于 wq</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;切换模式&quot;&gt;&lt;a href=&quot;#切换模式&quot; class=&quot;headerlink&quot; title=&quot;切换模式&quot;&gt;&lt;/a&gt;切换模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;esc 进入命令模式&lt;/li&gt;
&lt;li&gt;: 进入末尾模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;插入文本&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Vim" scheme="http://joe0708.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://joe0708.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重新学 Linux 命令</title>
    <link href="http://joe0708.github.io/2018/01/05/%E9%87%8D%E6%96%B0%E5%AD%A6-Linux-%E5%91%BD%E4%BB%A4/"/>
    <id>http://joe0708.github.io/2018/01/05/重新学-Linux-命令/</id>
    <published>2018-01-05T14:08:52.000Z</published>
    <updated>2018-01-14T16:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>options</p><ul><li>-a  显示隐藏文件</li><li>-l  以列表显示当前目录的文件</li><li>-h  以可读方式显示文件大小</li></ul><h4 id="man-command-command-–help"><a href="#man-command-command-–help" class="headerlink" title="man command | command –help"></a>man command | command –help</h4><p>显示 command 的帮助信息</p><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>显示之前执行的历史命令<br>!index 直接执行指定索引的历史命令</p><h4 id="more-filename"><a href="#more-filename" class="headerlink" title="more filename"></a>more filename</h4><p>与 cat 不同的是显示一屏内容 按 f\b(上一页\下一页)内容</p><h4 id="command-gt-filename"><a href="#command-gt-filename" class="headerlink" title="command &gt; filename"></a>command &gt; filename</h4><p>重定向到指定文件</p><h4 id="command-gt-gt-filename"><a href="#command-gt-gt-filename" class="headerlink" title="command &gt;&gt; filename"></a>command &gt;&gt; filename</h4><p>以追加的形式重定向到指定文件</p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><ul><li>cd -  跳转到上一次的路径</li><li>cd ~  跳转到home目录</li><li>cd .. 当前目录的上一个目录</li><li>cd ../.. 当前目录的上一个目录的上一个目录, 可以无限类推</li></ul><h4 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h4><p>递归</p><h4 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h4><p>强制删除</p><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>带参数 -s 创建软链接, 不到参数即硬链接</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>从文件中的查找指定内容<br>-v 不包含指定搜索内容的内容<br>-n 显示行号</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find path “query”<br>-name 以文件名搜索<br>-size 按大小搜索<br>-perm 按权限</p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>对文件打包<br>tar [参数] 打包文件名 文件<br>-c 生成档案文件,创建打包文件<br>-v 显示详细过程和进度<br>-f 指定档案文件名称<br>-t 列出档案中所有文件<br>-x 解开档案文件<br>-z 压缩/解压 .gz 后缀压缩文件<br>-j 压缩/解压 .bz2 后缀压缩文件</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查找指定命令所在的目录</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>查看进程信息, 默认只查看当前程序的进程信息<br>-aux 查看所有进程</p><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p>查看当前用户</p><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>添加用户</p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户<br>-r 删除用户时同时删除用户主目录</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>设置/修改 用户密码</p><h4 id="groudadd"><a href="#groudadd" class="headerlink" title="groudadd"></a>groudadd</h4><p>创建用户组</p><h4 id="groupdell"><a href="#groupdell" class="headerlink" title="groupdell"></a>groupdell</h4><p>删除用户组</p><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>查看所有用户组</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>sudo usermod -a -G 组名 用户名<br>-a 添加到用户组<br>-G 组名</p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>查看当前登录用户</p><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>chown 组名 文件名<br>修改文件所有者</p><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>chgrp 组名 文件名<br>修改文件所属组</p><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>修改文件权限</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ls&quot;&gt;&lt;a href=&quot;#ls&quot; class=&quot;headerlink&quot; title=&quot;ls&quot;&gt;&lt;/a&gt;ls&lt;/h4&gt;&lt;p&gt;options&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-a  显示隐藏文件&lt;/li&gt;
&lt;li&gt;-l  以列表显示当前目录的文件&lt;/li&gt;
&lt;li&gt;-h 
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://joe0708.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>fastlane boarding 实践笔记</title>
    <link href="http://joe0708.github.io/2017/12/23/fastlane-boarding-%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    <id>http://joe0708.github.io/2017/12/23/fastlane-boarding-实践笔记/</id>
    <published>2017-12-23T13:49:00.000Z</published>
    <updated>2018-01-14T16:48:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fastlane-boarding-实践笔记"><a href="#fastlane-boarding-实践笔记" class="headerlink" title="fastlane boarding 实践笔记"></a>fastlane boarding 实践笔记</h3><p>很长时间以来一直使用 <a href="https://wj.qq.com/" target="_blank" rel="noopener">腾讯问卷</a> 来收集 TestFlight 邮箱, 然后按模板导出SVG再导入到  iTunes Connect 中邀请测试, 如果有新的申请又得再次操作, 如此反复实在浪费精力.以至于后来懒得处理申请. 偶然发现 fastlane 自动化工具有个 <a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding</a> 服务专门用来简化这个功能, 只需要开发配置一下, 之后可以自动邀请, 完全不需要手工干预.</p><p><a href="https://github.com/fastlane/boarding" target="_blank" rel="noopener">boarding Github</a> Github上已经有详情的教程</p><h4 id="操作教程"><a href="#操作教程" class="headerlink" title="操作教程"></a>操作教程</h4><ol><li>注册 <a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku</a> 账号</li><li><img src="https://camo.githubusercontent.com/c0824806f5221ebb7d25e559568582dd39dd1170/68747470733a2f2f7777772e6865726f6b7563646e2e636f6d2f6465706c6f792f627574746f6e2e706e67" alt=""> 部署到 Heroku</li><li>如图, 填写App名称, iTunes Connect 账号、邮箱、报名, 其他配置可按需设置<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmr00td9i3j30jg0w80tu.jpg" alt=""></li><li>点击 <strong>Deploy app</strong> 等待部署, 完成之后点击 <strong>View</strong> 即可</li></ol><blockquote><p>boarding 会自动根据填写的 <strong>App name</strong> 生成一个二级域名, 并获取App图标和名称, 如图示</p><p> <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmr042vna5j30cg0lbdg1.jpg" alt=""></p></blockquote><h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><p>二步验证登录</p><blockquote><p>如果设置<strong>二步验证登录</strong>, 可以按照此文件配置 <a href="https://github.com/fastlane/fastlane/blob/master/spaceship/README.md#2-step-verification" target="_blank" rel="noopener">2-step-verification</a> </p></blockquote><p>错误提示 “无默认外部组”</p><blockquote><p>打开 Heroku App的配置页面, 点击 Setting -&gt; Config Variables -&gt; Reveal Config Vars, 添加一个配置变量, 如图示<br> <img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmr080qgd7j30z60bsaak.jpg" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;fastlane-boarding-实践笔记&quot;&gt;&lt;a href=&quot;#fastlane-boarding-实践笔记&quot; class=&quot;headerlink&quot; title=&quot;fastlane boarding 实践笔记&quot;&gt;&lt;/a&gt;fastlane boarding 实践
      
    
    </summary>
    
      <category term="iOS" scheme="http://joe0708.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://joe0708.github.io/tags/iOS/"/>
    
      <category term="fastlane" scheme="http://joe0708.github.io/tags/fastlane/"/>
    
  </entry>
  
  <entry>
    <title>Chromium for macOS 内置插件、自定义及自动化脚本(二)</title>
    <link href="http://joe0708.github.io/2017/12/23/Chromium-for-macOS-%E5%86%85%E7%BD%AE%E6%8F%92%E4%BB%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC-(%E4%BA%8C)/"/>
    <id>http://joe0708.github.io/2017/12/23/Chromium-for-macOS-内置插件、自定义及自动化脚本-(二)/</id>
    <published>2017-12-23T10:43:05.000Z</published>
    <updated>2018-01-14T16:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul><li><a href="http://www.cnblogs.com/honker/p/6397591.html" target="_blank" rel="noopener">内置插件及简单的自定义</a></li></ul><blockquote><p>以下大部分操作参考链接中已有，里面有说到这里不再赘述。</p><p>具体讲插件潜入和里面没有说到的点.</p><p>本文所有操作以 <strong>Cam</strong>(公司插件) 插件为例</p></blockquote><h3 id="一、嵌入插件"><a href="#一、嵌入插件" class="headerlink" title="一、嵌入插件"></a>一、嵌入插件</h3><ol><li><p>添加插件</p><p> 将 Cam 插件源码文件夹，复制到 <strong>src\chrome\browser\resources\</strong> 文件夹目录下</p></li><li><p>修改组件加载源码</p><p> 打开 <strong>src\chrome\browser\extensions\component_loader.cc</strong> 文件，<br>在 <strong>AddDefaultComponentExtensions()</strong> 函数中添加:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add(IDR_LOVENSE_MANIFEST,</span><br><span class="line">    base::FilePath(FILE_PATH_LITERAL(&quot;lovense_cam&quot;)));</span><br></pre></td></tr></table></figure><p><img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/98106686.jpg" alt=""></p><blockquote><p>IDR_LOVENSE_MANIFEST 为插件资源目录的Key, 所有关联插件资源的Key都使用这个</p><p>lovense_cam 对应插件源码的文件夹名 </p></blockquote><ol><li><p>关联插件的 mainfest.json 文件</p><p> 打开 <strong>src\chrome\browser\browser_resources.grd</strong> 文件并添加以下代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include name=&quot;IDR_LOVENSE_MANIFEST&quot; file=&quot;resources\lovense_cam\manifest.json&quot; type=&quot;BINDATA&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/89964911.jpg" alt=""></p><ol><li><p>添加白名单</p><p> 打开 <strong>src\chrome\browser\extensions\component_extensions_whitelist\whitelist.cc</strong> 文件，在 <strong>bool IsComponentExtensionWhitelisted(int manifest_resource_id)</strong> 函数中的 <strong>switch</strong> 语句中添加以下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case IDR_LOVENSE_MANIFEST:</span><br></pre></td></tr></table></figure></li></ol><pre><code>![](http://ojpb4w81b.bkt.clouddn.com/17-9-29/13887680.jpg)</code></pre><ol><li>添加插件文件路径映射关系</li></ol><p>打开 <strong>src\chrome\browser\resources\component_extension_resources.grd</strong> ，把除了mainfest.json文件之外的其他独立文件都加进来。</p><p>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include name=&quot;IDR_LOVENSE_128_PNG&quot;  file=&quot;lovense_cam\128.png&quot; type =&quot;BINDATA&quot; /&gt;</span><br></pre></td></tr></table></figure><p>附 Swift 脚本代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/// 转换XML之后的结果字符串</span><br><span class="line">var xmlString = &quot;&quot;</span><br><span class="line"></span><br><span class="line">/// 将插件文件夹内所有内容转换为XML 路径-&gt;文件名 键值对</span><br><span class="line">///</span><br><span class="line">/// - Parameter rootDir: 文件夹路径</span><br><span class="line">func convert2XML(rootDir: String) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        let folder = try FileManager.default.contentsOfDirectory(atPath: rootDir)</span><br><span class="line">        for itemPath in folder &#123;</span><br><span class="line">            let fullpath = rootDir.appending(&quot;/&quot; + itemPath)</span><br><span class="line">            let relPath = fullpath.replacingOccurrences(of: rootPath, with: parentDir)</span><br><span class="line">            </span><br><span class="line">            var isDir: ObjCBool = ObjCBool(false)</span><br><span class="line">            guard FileManager.default.fileExists(atPath: fullpath, isDirectory: &amp;isDir) else &#123; return &#125;</span><br><span class="line">            </span><br><span class="line">            if isDir.boolValue &#123;</span><br><span class="line">                convert2XML(rootDir: fullpath)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if [&quot;.DS_Store&quot;, &quot;manifest.json&quot;].contains(itemPath) &#123; continue &#125;</span><br><span class="line">                </span><br><span class="line">                let keyName = relPath</span><br><span class="line">                    .replacingOccurrences(of: &quot;/&quot;, with: &quot;_&quot;)</span><br><span class="line">                    .replacingOccurrences(of: &quot;.&quot;, with: &quot;_&quot;)</span><br><span class="line">                    .replacingOccurrences(of: &quot;-&quot;, with: &quot;_&quot;)</span><br><span class="line">                    .uppercased()</span><br><span class="line">                let xmlItem = &quot;&lt;include name=\&quot;IDR_&quot; + keyName + &quot;\&quot; file=\&quot;\(relPath)\&quot; type=\&quot;BINDATA\&quot; /&gt;&quot;</span><br><span class="line">                xmlString.append(xmlItem + &quot;\n&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(error)</span><br><span class="line">        exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tip：必须保证 key 不能有重复的<br>Lovense Browser 每次打包时， 如果插件资源文件有添加或删除需要重新生成。</p></blockquote><h3 id="二、其他修改"><a href="#二、其他修改" class="headerlink" title="二、其他修改"></a>二、其他修改</h3><ol><li><p>修改 Chromium 关于页面的名字<br>修改 <strong>src/chrome/app/settings_chromium_strings.grdp</strong> 文件中的 <strong>IDS_SETTINGS_ABOUT_PROGRAM</strong> 对应的值</p></li><li><p>修改 Chromium 关于页面的版本号<br>修改 <strong>src/out/Lovense/gen/components/version_info/version_info_values.h</strong> 文件中的 <strong>PRODUCT_VERSION</strong> 对应的值</p></li><li><p>注释掉从 DMG磁盘镜像中打开 Chromium 提示已到应用程序文件夹中的提示（引发此操作是 Chromium 内核，如果移到应用程序中， 只有 Chromium 内核会移过去，而启动器不会， 所以直接注释掉）</p><p> 打开 <strong>src/chrome/browser/chrome_browser_main_mac.mm</strong> 文件，注释掉<strong> void ChromeBrowserMainPartsMac::PreMainMessageLoopStart()</strong> 函数中 <strong>IsFirstRunSuppressed</strong> 判断</p><p> <img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/274156.jpg" alt=""></p></li></ol><h3 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h3><p>参考 <a href="http://192.168.0.5/zentao/doc-view-135.html" target="_blank" rel="noopener">编译教程</a></p><blockquote><p>添加资源文件后，编译可能会提示Key越界, 需将 <strong>src/tools/gritsettings/resource_ids</strong> 文件中中includes的值调大</p></blockquote><p><img src="http://ojpb4w81b.bkt.clouddn.com/17-9-29/56964818.jpg" alt=""></p><h3 id="四、打包"><a href="#四、打包" class="headerlink" title="四、打包"></a>四、打包</h3><ol><li>打开 <strong>LovenseBrowser.xcodeproj</strong> 项目，导出 <strong>iPa</strong> 安装包</li><li>src/out/Release/Lovense Browser 拷贝到 LovenseBrowser.app/ 目录中</li><li>修改启动器名字 Lovense Browser</li><li>使用 DropDMG 打包</li><li>将Lovense Browser.dmg和Lovense_Browser_Mac_Update.zip上传到服务器并更新后台版本号即可</li></ol><h3 id="五、脚本"><a href="#五、脚本" class="headerlink" title="五、脚本"></a>五、脚本</h3><p>以上所有操作均已使用脚本自动化</p><p>脚本地址：<a href="https://github.com/Joe0708/ChromiumBuild/tree/master" target="_blank" rel="noopener">Github</a></p><p><strong>chromiumBuild.sh</strong> : 主要用于 depot_tools 下载、 Chromium 源码自动下载编译，源码安装好后不需要再使用</p><p><strong>buildStarter.swift</strong> ： 主要用于每次打包时自动将插件文件夹复制到指定位置，自动生成文件映射关系并替换，并修改软件版本号</p><p><strong>build.sh</strong> : 主要用于编译 Chromium，打包 ipa 包，制作 DMG、Zip 文件</p><h3 id="六、自动化脚本使用"><a href="#六、自动化脚本使用" class="headerlink" title="六、自动化脚本使用"></a>六、自动化脚本使用</h3><ol><li><p>下载脚本源码</p></li><li><p>打开终端</p></li></ol><blockquote><ol><li>运行 buildStarter.swift 脚本，根据提示输入插件路径和版本号</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./buildStarter.swift</span><br></pre></td></tr></table></figure><blockquote><ol><li>运行 build.sh 脚本， 编译 Chromium、打包、制作 DMG、Zip 文件</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 如果终端提示没有权限，需在终端执行以下命令</p><p> chmod +x buildStarter.swift</p><p> chmod +x build.sh</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;参考链接：&quot;&gt;&lt;a href=&quot;#参考链接：&quot; class=&quot;headerlink&quot; title=&quot;参考链接：&quot;&gt;&lt;/a&gt;参考链接：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/honker/p/6397591.htm
      
    
    </summary>
    
    
      <category term="Chromium" scheme="http://joe0708.github.io/tags/Chromium/"/>
    
  </entry>
  
  <entry>
    <title>Chromium for macOS 编译教程(一)</title>
    <link href="http://joe0708.github.io/2017/12/23/Chromium-for-macOS-%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B(%E4%B8%80)/"/>
    <id>http://joe0708.github.io/2017/12/23/Chromium-for-macOS-编译教程(一)/</id>
    <published>2017-12-23T08:13:50.000Z</published>
    <updated>2018-01-14T16:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><ul><li>Mac (requied 10.11+)</li><li>Xcode IDE（required 7.3+）</li><li>Git（required 2.2.1+）</li><li>科学上网</li></ul><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul><li><p><a href="https://chromium.googlesource.com/chromium/src/+/lkcr/docs/mac_build_instructions.md" target="_blank" rel="noopener">官方编译教程</a></p></li><li><p><a href="https://www.chromium.org/developers/how-tos/get-the-code/working-with-release-branches" target="_blank" rel="noopener">官方 Release 分支编译教程</a></p></li><li><p><a href="http://www.cnblogs.com/honker/p/6397591.html" target="_blank" rel="noopener">内置插件及简单的自定义</a></p></li><li><p><a href="https://blink.lc/chromium/" target="_blank" rel="noopener">Chromium Release版本 信息</a></p></li></ul><h4 id="步骤概括："><a href="#步骤概括：" class="headerlink" title="步骤概括："></a>步骤概括：</h4><ol><li>安装 depot_tools 项目构建工具</li><li>使用 depot_tools 下载源码</li><li>编译 Chromium 源码</li><li>编译稳定版（Stable）分支</li></ol><h3 id="一、安装-depot-tools-项目构建工具"><a href="#一、安装-depot-tools-项目构建工具" class="headerlink" title="一、安装 depot_tools 项目构建工具"></a>一、安装 depot_tools 项目构建工具</h3><ol><li>克隆 depot_tools git仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure><ol><li>添加环境变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=&quot;$PATH:/path/to/depot_tools&quot;</span><br></pre></td></tr></table></figure><blockquote><p>Tip: <strong>/path/to/depot_tools</strong>， 为你 depot_tools 本地的路径</p></blockquote><h3 id="二、使用-depot-tools-下载源码"><a href="#二、使用-depot-tools-下载源码" class="headerlink" title="二、使用 depot_tools 下载源码"></a>二、使用 depot_tools 下载源码</h3><ol><li>创建一个用于存在 chromium 的目录 (您可以任意命令，并存放在任何您喜欢的位置，只要是路径路径并且没有空格即可）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir chromium &amp;&amp; cd chromium</span><br></pre></td></tr></table></figure><ol><li>使用 depot_tools 的 fetch 命令，来检查代码及其依赖关系。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fetch --no-history chromium</span><br></pre></td></tr></table></figure><blockquote><p>Tip: –no-history： 代表不需要历史记录， 完整仓库大约40G<br>        源码大小大概 8G 左右，下载时间因网速而议，请耐心等待</p></blockquote><h3 id="三、编译-Chromium-源码"><a href="#三、编译-Chromium-源码" class="headerlink" title="三、编译 Chromium 源码"></a>三、编译 Chromium 源码</h3><ol><li>进入源码目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br></pre></td></tr></table></figure><ol><li>生成编译配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn args out/Release</span><br></pre></td></tr></table></figure><blockquote><p>out/<strong>Release</strong> 中 Release 并非固定，可以随意取名</p></blockquote><ol><li>设置编译配置选项</li></ol><p>执行以上命令之后，此时会进入 Vim 编辑模式<br>按字母键 <code>o</code> 进入编辑模式，粘贴一下配置项<br>按 <code>:wq</code> 退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target_cpu = &quot;x64&quot;</span><br><span class="line">is_debug = false</span><br><span class="line">symbol_level = 0</span><br><span class="line">enable_nacl = true</span><br><span class="line">remove_webcore_debug_symbols = true</span><br><span class="line">ffmpeg_branding = &quot;Chrome&quot;</span><br><span class="line">proprietary_codecs = true</span><br><span class="line">enable_iterator_debugging = false</span><br><span class="line">exclude_unwind_tables = true</span><br></pre></td></tr></table></figure><blockquote><p>具体配置信息见：<a href="https://chromium.googlesource.com/chromium/src/+/lkcr/tools/gn/docs/quick_start.md" target="_blank" rel="noopener">链接</a></p></blockquote><ol><li>编译代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ninja -C out/Release chrome</span><br></pre></td></tr></table></figure><blockquote><p>out/<strong>Release</strong> 中 Release 并非固定，可以随意取名</p></blockquote><ol><li>运行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ out/Release/Chromium.app/Contents/MacOS/Chromium</span><br></pre></td></tr></table></figure><blockquote><p>编译文件大约 3W 左右， 需要 4-8 个小时</p></blockquote><h3 id="四、编译稳定版（Stable）分支"><a href="#四、编译稳定版（Stable）分支" class="headerlink" title="四、编译稳定版（Stable）分支"></a>四、编译稳定版（Stable）分支</h3><ol><li>检查分支（option）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --tags</span><br></pre></td></tr></table></figure><ol><li>根据指定分支创建分支，并切换到该分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b LovenseBrowser_61.0.3163.100 tags/61.0.3163.100</span><br></pre></td></tr></table></figure><ol><li>同步代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gclient sync --with_branch_heads --jobs 16</span><br></pre></td></tr></table></figure><ol><li>编译代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ninja -C out/Release chrome</span><br></pre></td></tr></table></figure><ol><li>运行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ out/Release/Chromium.app/Contents/MacOS/Chromium</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 同第三步中的第4、5步</p></blockquote><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>以上所以步骤均已写入脚本，可以使用脚本代替。</p><p>脚本链接： <a href="https://github.com/Joe0708/ChromiumBuild/blob/master/chromiumBuild.sh" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;准备工作：&quot;&gt;&lt;a href=&quot;#准备工作：&quot; class=&quot;headerlink&quot; title=&quot;准备工作：&quot;&gt;&lt;/a&gt;准备工作：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Mac (requied 10.11+)&lt;/li&gt;
&lt;li&gt;Xcode IDE（required 7.3
      
    
    </summary>
    
    
      <category term="Chromium" scheme="http://joe0708.github.io/tags/Chromium/"/>
    
  </entry>
  
  <entry>
    <title>Call to undefined function mysql_connect()</title>
    <link href="http://joe0708.github.io/2016/11/21/Call%20to%20undefined%20function%20mysql%20connect/"/>
    <id>http://joe0708.github.io/2016/11/21/Call to undefined function mysql connect/</id>
    <published>2016-11-21T02:23:16.000Z</published>
    <updated>2018-01-14T14:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习PHP连接mysql,对着教程练习,代码什么都没问题,但是总无法连接成功,提示调用了未定义的函数,错误如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call to undefined function mysql_connect()</span><br></pre></td></tr></table></figure><p>网上胡乱搜了一番, 都是说<strong>PHP.ini</strong>文件配置问题.</p><p>SO, 屁颠屁颠的去找这个文件按照网上的答案改什么 <strong>extension_dir</strong>, 放开<strong>extension=php_mysql.dll</strong>的注释, Command + F ,结果啥也没搜到, WTF(黑人脸).这下懵逼了.</p><p>因为用的是Mac电脑,所以以为是系统原因导致配置文件的格式不一样? 结果又搜索了一番, 还是无果.机智如我,最后看了文档手册才发现<strong>PHP7</strong>已经废掉了mysql模块,官方推荐使用<strong>mysqli</strong>和<strong>PDO</strong>, 最后使用了最新模块顺利解决问题!</p><p>oh yeah~</p><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f9yr3mp2j6j20jc0f6ab5.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9yr51f501j20om05aq3a.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习PHP连接mysql,对着教程练习,代码什么都没问题,但是总无法连接成功,提示调用了未定义的函数,错误如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="PHP" scheme="http://joe0708.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://joe0708.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="http://joe0708.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础 - 增删改查</title>
    <link href="http://joe0708.github.io/2016/11/21/SQL%20basic%20CURD/"/>
    <id>http://joe0708.github.io/2016/11/21/SQL basic CURD/</id>
    <published>2016-11-21T02:20:40.000Z</published>
    <updated>2018-01-14T14:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、增加记录"><a href="#1、增加记录" class="headerlink" title="1、增加记录"></a>1、增加记录</h2><pre><code>语法格式: insert into table_name(field 1,field2, field3,...) values(value 1,value 2, value 3,...)语法说明:     * insert into : 添加数据的SQL命令.    * table_name : 要添加数据的数据表名.    * 表的字段列表, 要与值的列表一一对应.    * 字段的类型,要与值类型一致.    * 如果还有没列出的字段, 将用默认值代替.举例:    insert into student(name, gender, profile) values (&apos;Joe&apos;,1,&apos;大家好,我在学习SQL&apos;);</code></pre><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9ylprvw7tj20vk09swgb.jpg" alt=""></p><h2 id="2、删除记录"><a href="#2、删除记录" class="headerlink" title="2、删除记录"></a>2、删除记录</h2><pre><code>语法格式: delete from table_name [where 条件]语法说明:    * delete from : 删除数据的SQL命令.    * table_name : 要删除数据的数据表名.    * where 条件 : 如果省略条件, 将删除所有记录.举例:     * delete from student : //删除所有记录    * delete from student where id&gt;10; //删除 id&gt;10 的所有记录    * delete from student where id&gt;19 and id&lt;20; //删除 id&gt;10 并且 id&lt;20 的所有记录    * delete from student where name=&apos;Joe&apos; and id&lt;100; //删除 name=&apos;Joe&apos; 并且 id&lt;100的所有记录</code></pre><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f9ylz8r2d0j20kg0fk777.jpg" alt=""></p><h2 id="3、修改记录"><a href="#3、修改记录" class="headerlink" title="3、修改记录"></a>3、修改记录</h2><pre><code>语法格式: update table_name set 字段1=新值1, 字段2=新值2,... [where 条件]语法说明:    * 需要更新的字段列出, 不需要更新的不用管.    * 字段的顺序可以修改.    * where 条件不能省略, 如果省略会导致所有记录都会修改成一样举例:</code></pre><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9ym5mralqj20to08m761.jpg" alt=""></p><h2 id="4、查询记录"><a href="#4、查询记录" class="headerlink" title="4、查询记录"></a>4、查询记录</h2><pre><code>语法格式: select 字段列表 | * from table_name [where 条件] [order by 排序] [limit 限制条数]语法说明:    * 字段列表 : 查询某些字段的数据, 各字段之间用逗号隔开, 字段之间不分顺序    * &apos;*&apos; : 表示显示所有列数据 如: select * from student;    * where : 查询指定的条件的数据        - select * from student where id&lt;10;        - select * from student where id&lt;100 and gender=1;        - select * from student where id=100 or gender=0;    * order by : 字段排序        - 语法 : order by 字段 [asc | desc].        - asc 表示 &quot;升序&quot; 排列(默认), desc 表示 &quot;降序&quot;排列.        - select * from student order by id desc; //id 降序排列    * limit : 限制输出        - 语法 : limit startrow,pagesize        - 参数 :             * startrow 从指定的行数起开发返回数据.            * pagesize 返回的记录数        - 举例 :            * limit 0,10; //从第0行起,返回10条记录            * limit 10,10; //从第10行起,返回10条记录            * limot 20,10; //从第20行起,返回10条记录 </code></pre><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:center">名称</th><th style="text-align:right">应用</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:center">等于</td><td style="text-align:right">id=3</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:center">大于</td><td style="text-align:right">id&gt;5</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:center">小于</td><td style="text-align:right">id&lt;5</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:right">id&gt;=5</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:center">小于等于</td><td style="text-align:right">id&lt;=5</td></tr><tr><td style="text-align:left">!=或者&lt;&gt;</td><td style="text-align:center">不等于</td><td style="text-align:right">id!=5</td></tr><tr><td style="text-align:left">is not null</td><td style="text-align:center">不为空</td><td style="text-align:right">id is not null</td></tr><tr><td style="text-align:left">is null</td><td style="text-align:center">为空</td><td style="text-align:right">title is null</td></tr><tr><td style="text-align:left">bwtween</td><td style="text-align:center">两者之间</td><td style="text-align:right">id between 1 and 10</td></tr><tr><td style="text-align:left">in</td><td style="text-align:center"></td><td style="text-align:right">id in(1,3,5)</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:center"></td><td style="text-align:right">id not in(1,3,5)</td></tr><tr><td style="text-align:left">like</td><td style="text-align:center">模式匹配</td><td style="text-align:right">name like(‘jerry%’)</td></tr><tr><td style="text-align:left">not like</td><td style="text-align:center">模式匹配</td><td style="text-align:right">name not like(‘jerry%’);</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、增加记录&quot;&gt;&lt;a href=&quot;#1、增加记录&quot; class=&quot;headerlink&quot; title=&quot;1、增加记录&quot;&gt;&lt;/a&gt;1、增加记录&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;语法格式: insert into table_name(field 1,field2, f
      
    
    </summary>
    
      <category term="PHP" scheme="http://joe0708.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://joe0708.github.io/tags/PHP/"/>
    
      <category term="SQL" scheme="http://joe0708.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库基本操作</title>
    <link href="http://joe0708.github.io/2016/11/21/database%20basic%20operate/"/>
    <id>http://joe0708.github.io/2016/11/21/database basic operate/</id>
    <published>2016-11-21T02:15:36.000Z</published>
    <updated>2018-01-14T14:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-数据库操作"><a href="#MySQL-数据库操作" class="headerlink" title="MySQL 数据库操作"></a>MySQL 数据库操作</h2><h3 id="1、登陆到MySQL服务器"><a href="#1、登陆到MySQL服务器" class="headerlink" title="1、登陆到MySQL服务器"></a>1、登陆到MySQL服务器</h3><pre><code>语法格式 : mysql -u用户名 -p密码参数说明 : * /Applications/MAMP/Library/bin/mysql : 代表mysql的主程序 * -u : 代表MySQL用户名,后面紧跟密码, 如 -uroot * -p : 代表MySQL密码, 后面紧跟密码, 如 -proot举例:     /Applications/MAMP/Library/bin/mysql -uroot -proot</code></pre><h3 id="2、显示所有已有数据库"><a href="#2、显示所有已有数据库" class="headerlink" title="2、显示所有已有数据库"></a>2、显示所有已有数据库</h3><pre><code>语法格式 : show databases;</code></pre><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f9yfx4bzvuj20ag07imxv.jpg" alt=""></p><h3 id="3、-创建数据库"><a href="#3、-创建数据库" class="headerlink" title="3、 创建数据库"></a>3、 创建数据库</h3><pre><code>语法格式 : create database [if not exists] db_name [charset utf8]参数说明    * create database : MySQL命令,创建一个数据库    * if not exists : 可选项,如果这个数据库不存在则创建数据库.    * db_name : 数据库的名称    * charset : 可选项,设置数据库的字符集(默认lain1)举例: create database if not exists student charset utf8;</code></pre><p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f9yg6s52oaj20aw08ot9g.jpg" alt=""></p><h3 id="4、-删除数据库"><a href="#4、-删除数据库" class="headerlink" title="4、 删除数据库"></a>4、 删除数据库</h3><pre><code>语法格式 : drop database [if exists] db_name;参数说明    * drop database: MySQL命令, 删除一个数据库    * if exists : 可选项, 如果存在则删除数据库    * db_name : 数据库名举例: drop database if exists student;</code></pre><h3 id="5、MySQL数据库字符集"><a href="#5、MySQL数据库字符集" class="headerlink" title="5、MySQL数据库字符集"></a>5、MySQL数据库字符集</h3><ol><li><p>查看数据库的字符集</p><pre><code>语法格式 : show create database db_name;举例: show create database student;</code></pre><p> <img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f9ygdx6tb4j20vg09u404.jpg" alt=""></p></li><li><p>修改数据库的字符集</p><pre><code>语法格式 : alter database db_name default character set utf8;举例: alter database student default character set utf8;</code></pre></li></ol><h2 id="MySQL-数据表操作"><a href="#MySQL-数据表操作" class="headerlink" title="MySQL 数据表操作"></a>MySQL 数据表操作</h2><h3 id="1、选择数据库"><a href="#1、选择数据库" class="headerlink" title="1、选择数据库"></a>1、选择数据库</h3><pre><code>描述 : 选择所需要操作的数据库语法格式 : user db_name    举例: user student;</code></pre><h3 id="2、显示所有的数据表"><a href="#2、显示所有的数据表" class="headerlink" title="2、显示所有的数据表"></a>2、显示所有的数据表</h3><pre><code>描述 : 选择当前所操作数据库下的所有数据表语法格式 : show tables</code></pre><h3 id="3、创建数据表"><a href="#3、创建数据表" class="headerlink" title="3、创建数据表"></a>3、创建数据表</h3><pre><code>描述 : 在当前数据库中创建一个数据表语法格式 : create table table_name(col_name col_type col_attr,col_name col_type col_attr,...)参数说明 :    * create table : 创建一个数据表    * table_name : 数据表表名    * col_name : 列的名称    * col_type : 列的类型.(eg: tinyint、int、bigint、char、varchar、text、date、time等)    * col_attr : 列的属性        - not null | null : 该列是否可以为空.        - default default_value : 指定该列的默认值.        - default_value 默认是字符串, 也可以是整型        - auto_increment : 该列值为自动增长型,或者自动编号.类型必须是整型        - primary key : 主键. 指定该列的值具有唯一性, 不能为空.(配合 not null 使用), 一个表只能有一个主键        - id 字段的属性必须有: not null auto_increment primary key注意: 一个数据表,由多个列构成.多个列定义之间用英文逗号隔开举例: </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; create table student(</span><br><span class="line">   id int not null auto_increment primary key,</span><br><span class="line">   name varchar(20) not null,</span><br><span class="line">   gender tinyint,</span><br><span class="line">  profile text</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p> <img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9yjjuovs1j20ju0cy404.jpg" alt=""></p><h3 id="4、查看数据表结构"><a href="#4、查看数据表结构" class="headerlink" title="4、查看数据表结构"></a>4、查看数据表结构</h3><pre><code>语法格式 : describe table_name;举例 : describe student;</code></pre><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f9yjrevf9pj20pw08i762.jpg" alt=""></p><h3 id="5、修改数据表"><a href="#5、修改数据表" class="headerlink" title="5、修改数据表"></a>5、修改数据表</h3><pre><code>语法格式 : alter table举例 : 详情可参考MySQL语法手册, 在此不演示</code></pre><h3 id="6、删除数据表"><a href="#6、删除数据表" class="headerlink" title="6、删除数据表"></a>6、删除数据表</h3><pre><code>语法格式 : drop table [if exists] table_name;举例 : drop table student;</code></pre><h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><ol><li>整型浮点型</li></ol><ul><li>整型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">描述</th><th style="text-align:right">范围</th><th style="text-align:right">大小</th></tr></thead><tbody><tr><td style="text-align:left">tinyint</td><td style="text-align:center">最小型整数</td><td style="text-align:right">0~255(-128 ~ + 127)</td><td style="text-align:right">一个字节</td></tr><tr><td style="text-align:left">smallint</td><td style="text-align:center">小型整数</td><td style="text-align:right">0~65535</td><td style="text-align:right">二个字节</td></tr><tr><td style="text-align:left">mediumint</td><td style="text-align:center">中型整数</td><td style="text-align:right">0~1677万</td><td style="text-align:right">三个字节</td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">一般整数</td><td style="text-align:right">0~21亿</td><td style="text-align:right">四个字节</td></tr><tr><td style="text-align:left">bigint</td><td style="text-align:center">最大整数</td><td style="text-align:right">0~42亿</td><td style="text-align:right">八个字节</td></tr></tbody></table><ul><li>浮点型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">范围</th><th style="text-align:right">描述</th><th style="text-align:right">举例</th></tr></thead><tbody><tr><td style="text-align:left">float(m,d)</td><td style="text-align:center">单精度(精确到小数点后7位)</td><td style="text-align:right">M代表长度, D代表小数位数</td><td style="text-align:right">float(6,2) 总长度为6位,小数位为2位,小数点不算,最大值为9999.99</td></tr><tr><td style="text-align:left">double(m.d)</td><td style="text-align:center">双精度(精确到小数点后15位)</td><td style="text-align:right">M代表长度, D代表小数位数</td><td style="text-align:right"></td></tr></tbody></table><ol><li>日期时间型</li></ol><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">描述</th><th style="text-align:right">格式</th></tr></thead><tbody><tr><td style="text-align:left">date</td><td style="text-align:center">日期型</td><td style="text-align:right">“YYYY-MM-DD”</td></tr><tr><td style="text-align:left">time</td><td style="text-align:center">时间型</td><td style="text-align:right">“00:00:00”</td></tr></tbody></table><ol><li>字符、文本型</li></ol><ul><li>字符型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">范围</th><th style="text-align:right">描述</th><th style="text-align:right">大小</th><th>举例</th></tr></thead><tbody><tr><td style="text-align:left">char(m)</td><td style="text-align:center">0~255</td><td style="text-align:right">m代表长度, 固定长度的字符串</td><td style="text-align:right">一个字节</td><td>如:邮编、手机号码、电话号码等</td></tr><tr><td style="text-align:left">varchar(m)</td><td style="text-align:center">0~65535</td><td style="text-align:right">m代表长度, 可变长度的字符串</td><td style="text-align:right">二个字节</td><td>如:新闻标题、家庭地址、毕业院校等</td></tr></tbody></table><ul><li>文本型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">范围</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:left">tinytext</td><td style="text-align:center">0~255</td><td style="text-align:right">小型文本</td></tr><tr><td style="text-align:left">text</td><td style="text-align:center">0~1670万</td><td style="text-align:right">中型文本</td></tr><tr><td style="text-align:left">longtext</td><td style="text-align:center">0~42亿</td><td style="text-align:right">大型文本</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-数据库操作&quot;&gt;&lt;a href=&quot;#MySQL-数据库操作&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库操作&quot;&gt;&lt;/a&gt;MySQL 数据库操作&lt;/h2&gt;&lt;h3 id=&quot;1、登陆到MySQL服务器&quot;&gt;&lt;a href=&quot;#1、登陆
      
    
    </summary>
    
      <category term="PHP" scheme="http://joe0708.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://joe0708.github.io/tags/PHP/"/>
    
      <category term="MySQL" scheme="http://joe0708.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>利用 CrossOver 安装Windows应用程序</title>
    <link href="http://joe0708.github.io/2016/10/24/Crossover%20guide/"/>
    <id>http://joe0708.github.io/2016/10/24/Crossover guide/</id>
    <published>2016-10-24T01:35:23.000Z</published>
    <updated>2018-01-14T15:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前言: 鉴于最近太多人问软件使用教程, 这里拿Windows版微信的安装做个简单演示, 其他软件安装流程一样</span><br></pre></td></tr></table></figure><hr><h2 id="步骤-一"><a href="#步骤-一" class="headerlink" title="步骤 一:"></a>步骤 一:</h2><p>打开软件后 <strong>点击安装 Windows 应用程序</strong></p><p><img src="http://ww4.sinaimg.cn/large/801b780agw1f920mb3t1fj216o10e424.jpg" alt="image"></p><hr><h2 id="步骤-二"><a href="#步骤-二" class="headerlink" title="步骤 二:"></a>步骤 二:</h2><p>输入你要安装的Windows软件, 如果列表中没有,选择 <strong>未列出的应用程序”xxxx”</strong> ,然后点击右下角继续</p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f921n1ln69j212g0y40v3.jpg" alt=""></p><hr><h2 id="步骤-三"><a href="#步骤-三" class="headerlink" title="步骤 三:"></a>步骤 三:</h2><p>点击 <strong>选择安装文件</strong> , 选择你要安装的Windows应用程序的安装包, 这里我已经提前将Windows版的微信下载下来, 直接选择安装包后点击<strong>继续</strong>然后<strong>安装</strong>即可。 如果你没有安装包, 需要先下载安装包</p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f920rjopklj219414s0yh.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f921pprk6lj21320yyjvc.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/801b780agw1f921qetg99j21320ymgpf.jpg" alt=""></p><p><img src="http://ww3.sinaimg.cn/large/801b780agw1f921qwz7mgj213c0ycn04.jpg" alt=""></p><hr><h2 id="步骤-四"><a href="#步骤-四" class="headerlink" title="步骤 四:"></a>步骤 四:</h2><p>到这一步, 软件会自动安装, 如果软件依赖的框架或运行环境较多, 就会导致安装过程比较长,请耐心等待</p><p>安装过程中会出现跟Windows上一样的安装过程, 按正常的流程安装即可</p><p>安装流程完成请退出你安装的软件,如果软件在运行过程中,会阻塞CrossOver的正常安装</p><p><img src="http://ww1.sinaimg.cn/large/801b780agw1f921rkd4t0j213e0yqwi0.jpg" alt=""></p><hr><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>利用Crossover成功将微信安装在Mac上,但是使用时却发现输入文字时输入框并没有文字显示</p><p>可以总结出软件兼容性不是很好,所有这里并不建议大家安装大型软件或游戏, 安装一些小应用倒无妨</p><p>如果你实在需要运行但Crossover无法兼容满足你的软件, 你还可以用虚拟机来代替。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>视频操作教程: <a href="https://pan.baidu.com/s/1pLhdljX" target="_blank" rel="noopener">链接</a> 密码: <strong>4ezh</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="软件" scheme="http://joe0708.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="macOS" scheme="http://joe0708.github.io/tags/macOS/"/>
    
      <category term="CrossOver" scheme="http://joe0708.github.io/tags/CrossOver/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS Sierra(10.12) 安全与隐私没有允许任何来源的选项 </title>
    <link href="http://joe0708.github.io/2016/09/22/macOSSierra/"/>
    <id>http://joe0708.github.io/2016/09/22/macOSSierra/</id>
    <published>2016-09-22T05:37:32.000Z</published>
    <updated>2018-01-14T14:48:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>不少用户更新到最新系统 <strong>macOS Sierra</strong> 后发现系统偏好设置-&gt;安全性与隐私中默认已经隐藏了运行安装任何来源App的选项, 如图<br><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f82boff8etj20g40di3z6.jpg" alt="image"></p><p>因为增强了GateKeeper的安全性，所以该选项被隐藏，目的在于避免除Mac AppStore和正规签名外的未知或未签名App在系统内被任意执行，从而威胁用户隐私和系统安全。但这也导致很多不是从AppStore中下载的软件或破解版的软件将无法使用, 这也造成了很多不便。在<strong>macOS Sierra</strong>系统中<strong>GateKeeper</strong> 默认是打开的, 所以我们只需关掉<strong>GateKeeper</strong>即可看到<strong>任何来源</strong>的选项了</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>1.打开应用程序-&gt;实用工具-&gt;终端</p><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f82bc2itoyj20oi0f8jtp.jpg" alt="image"></p><p>2.在终端中输入命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>3.敲回车, 然后验证口令后即可(电脑密码, 注意:输入密码时屏幕上不会有任何显示,实际已经输入,输入完后敲回车即可)。</p><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f82bqnrca6j20i60ci74l.jpg" alt="image"></p><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f82bpp0eovj20lo0i6dh5.jpg" alt="image"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果你不想打开这个全局设置, 你也可以针对某个应用开启选项</p><p>同上操作,输入命令时换成以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/应用.app</span><br></pre></td></tr></table></figure></p><p>注意 “应用.app” 换成你需要解锁的app, 例如QQ的安装路径是 /Applications/QQ.app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/QQ.app</span><br></pre></td></tr></table></figure></p><p>如果不会操作可以下载这个命令行脚本, 解压后打开运行直接输入电脑密码即可</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1qXE9vEs" target="_blank" rel="noopener">https://pan.baidu.com/s/1qXE9vEs</a> 密码: 7rwq</p></blockquote><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">Apple</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不少用户更新到最新系统 &lt;strong&gt;macOS Sierra&lt;/strong&gt; 后发现系统偏好设置-&amp;gt;安全性与隐私中默认已经隐藏了运行安装任何来源App的选项, 如图&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/65e4f1e
      
    
    </summary>
    
      <category term="macOS" scheme="http://joe0708.github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://joe0708.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>利用 AFNetworking + YYCache 对网络请求进行简单缓存</title>
    <link href="http://joe0708.github.io/2016/09/14/AFNetworking%20YYCache/"/>
    <id>http://joe0708.github.io/2016/09/14/AFNetworking YYCache/</id>
    <published>2016-09-14T08:45:34.000Z</published>
    <updated>2018-01-14T14:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在开发中我们常常需要向服务器发送请求来获得数据, 正常的流程是这样:</p><ol><li>发送请求</li><li>网络正常, 将数据刷新到UI</li><li>无网络，没有数据, 视图空白</li></ol><p>这样就会导致同一个URL请求多次，服务器返回的数据可能都是一样的，比如服务器上的某张图片，无论下载多少次，返回的数据都是一样的。这样的情况可能会导致一下问题:</p><ol><li>重复获取数据，造成用户流量的浪费</li><li>请求响应速度可能很慢</li><li>服务器不必要的压力</li><li>没网络的情况下没有数据</li><li>…</li></ol><p>所以为了解决上面的问题，我们一般会对数据进行缓存处理，给用户更好的用户体验，减轻服务器的压力，实现缓存后的步骤:</p><ol><li>先判断是否有缓存数据，如果有先加载缓存数据</li><li>判断有没有网络</li><li>没网,结束.</li><li>有网，继续请求，刷新数据，将服务器的数据缓存到硬盘</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>在iOS中，苹果已经为我们提供了<strong>NSURLCache</strong>类来实现缓存</p><p>但是这里我并没有使用苹果提供的，而是第三方<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>来实现对网络请求的缓存</p><p>使用<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>进行网络请求管理</p><ul><li>对GET请求进行缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 发送 GET 请求</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *   GET请求</span><br><span class="line"> *</span><br><span class="line"> *   @param url           url</span><br><span class="line"> *   @param params        请求的参数字典</span><br><span class="line"> *   @param cache         是否缓存</span><br><span class="line"> *   @param successBlock  成功的回调</span><br><span class="line"> *   @param failureBlock  失败的回调</span><br><span class="line"> *   @param showHUD       是否加载进度指示器</span><br><span class="line"> */</span><br><span class="line">+ (NSURLSessionTask *)getRequestWithUrl:(NSString *)url</span><br><span class="line">                                 params:(NSDictionary *)params</span><br><span class="line">                                  cache:(BOOL)isCache</span><br><span class="line">                           successBlock:(QCSuccessBlock)successBlock</span><br><span class="line">                           failureBlock:(QCFailureBlock)failureBlock</span><br><span class="line">                                showHUD:(BOOL)showHUD&#123;</span><br><span class="line">    </span><br><span class="line">    __block NSURLSessionTask *session = nil;</span><br><span class="line"></span><br><span class="line">    if (isCache) &#123;</span><br><span class="line">        </span><br><span class="line">        id responseObject = [QCNetworkCache getCacheResponseObjectWithRequestUrl:url params:params];</span><br><span class="line">        </span><br><span class="line">        if (responseObject) &#123;</span><br><span class="line">            </span><br><span class="line">            int code = 0;</span><br><span class="line">            NSString *msg = nil;</span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                //这个字段取决于 服务器</span><br><span class="line">                code                = [responseObject[@&quot;rsCode&quot;] intValue];</span><br><span class="line">                msg                 = responseObject[@&quot;rsMsg&quot;];</span><br><span class="line">            &#125;</span><br><span class="line">            successBlock ? successBlock(responseObject, code, msg) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //没有网络直接返回</span><br><span class="line">    if (networkStatus == QCNetworkStatusNotReachable) &#123;</span><br><span class="line">        failureBlock ? failureBlock(QC_ERROR) : 0;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(showHUD) NSLog(@&quot;加载中&quot;);</span><br><span class="line"></span><br><span class="line">    session = [_manager GET:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line"></span><br><span class="line">        int code = 0;</span><br><span class="line">        NSString *msg = nil;</span><br><span class="line">        </span><br><span class="line">        if (responseObject) &#123;</span><br><span class="line">            //这个字段取决于 服务器</span><br><span class="line">            code                = [responseObject[@&quot;rsCode&quot;] intValue];</span><br><span class="line">            msg                 = responseObject[@&quot;rsMsg&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        successBlock ? successBlock(responseObject, code, msg) : 0;</span><br><span class="line">        </span><br><span class="line">        //缓存数据</span><br><span class="line">        isCache ? [QCNetworkCache cacheResponseObject:responseObject requestUrl:url params:params] : 0;</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line">        failureBlock ? failureBlock(error) : 0;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [session resume];</span><br><span class="line">    </span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存缓存具体实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  对请求进行缓存</span><br><span class="line"> *</span><br><span class="line"> *  @param responseObject 需要缓存的数据</span><br><span class="line"> *  @param requestUrl     请求url</span><br><span class="line"> *  @param params         参数</span><br><span class="line"> */</span><br><span class="line">+ (void)cacheResponseObject:(id)responseObject</span><br><span class="line">                 requestUrl:(NSString *)requestUrl</span><br><span class="line">                     params:(NSDictionary *)params&#123;</span><br><span class="line">    assert(responseObject);</span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    if (!params) params = @&#123;&#125;;</span><br><span class="line">    NSString *originString = [NSString stringWithFormat:@&quot;%@-%@&quot;,requestUrl,params];</span><br><span class="line">    NSString *hash = [self md5:originString];</span><br><span class="line">    </span><br><span class="line">    [cache setObject:responseObject forKey:hash withBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;成功 hash = %@&quot;, hash);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取已缓存的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  获取已缓存的请求</span><br><span class="line"> *</span><br><span class="line"> *  @param requestUrl 请求地址</span><br><span class="line"> *  @param params     参数</span><br><span class="line"> *</span><br><span class="line"> *  @return 缓存的数据</span><br><span class="line"> */</span><br><span class="line"> + (id)getCacheResponseObjectWithRequestUrl:(NSString *)requestUrl</span><br><span class="line">                                    params:(NSDictionary *)params&#123;</span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    if (!params) params = @&#123;&#125;;</span><br><span class="line">    NSString *originString = [NSString stringWithFormat:@&quot;%@-%@&quot;,requestUrl,params];</span><br><span class="line">    NSString *hash = [self md5:originString];</span><br><span class="line">    </span><br><span class="line">    id cacheData = [cache objectForKey:hash];</span><br><span class="line">    </span><br><span class="line">    return cacheData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对下载请求进行缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 文件下载</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  文件下载 (带缓存)</span><br><span class="line"> *</span><br><span class="line"> *  @param url           下载文件接口地址</span><br><span class="line"> *  @param progressBlock 下载进度</span><br><span class="line"> *  @param successBlock  成功回调</span><br><span class="line"> *  @param failBlock     下载回调</span><br><span class="line"> *  @param showHUD       是否加载进度指示器</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求</span><br><span class="line"> */</span><br><span class="line">+ (NSURLSessionTask *)downloadWithUrl:(NSString *)url</span><br><span class="line">                        progressBlock:(QCProgressBlock)progressBlock</span><br><span class="line">                         successBlock:(QCDownloadSuccessBlock)successBlock</span><br><span class="line">                         failureBlock:(QCFailureBlock)failureBlock</span><br><span class="line">                              showHUD:(BOOL)showHUD&#123;</span><br><span class="line">    </span><br><span class="line">    __block NSURLSessionTask *session = nil;</span><br><span class="line">    </span><br><span class="line">    NSString *type = nil;</span><br><span class="line">    NSArray *subStringArr = nil;</span><br><span class="line">    </span><br><span class="line">    NSURL *fileUrl = [QCNetworkCache getDownloadDataFromCacheWithRequestUrl:url];</span><br><span class="line">    </span><br><span class="line">    if (fileUrl) &#123;</span><br><span class="line">        if (successBlock) successBlock(fileUrl);</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //没有网络直接返回</span><br><span class="line">    if (networkStatus == QCNetworkStatusNotReachable) &#123;</span><br><span class="line">        failureBlock ? failureBlock(QC_ERROR) : 0;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(showHUD) NSLog(@&quot;加载中&quot;);</span><br><span class="line">    </span><br><span class="line">    if (url) &#123;</span><br><span class="line">        subStringArr = [url componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">        if (subStringArr.count &gt; 0) &#123;</span><br><span class="line">            type = subStringArr[subStringArr.count - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //响应内容序列化为二进制</span><br><span class="line">    _manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    session = [_manager GET:url parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        </span><br><span class="line">        progressBlock ? progressBlock((float)downloadProgress.completedUnitCount/(float)downloadProgress.totalUnitCount) : 0;</span><br><span class="line"></span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line">        </span><br><span class="line">        if (successBlock) &#123;</span><br><span class="line">            NSData *data = (NSData *)responseObject;</span><br><span class="line">            </span><br><span class="line">            [QCNetworkCache saveDownloadData:data requestUrl:url];</span><br><span class="line">            </span><br><span class="line">            NSURL *downFileUrl = [QCNetworkCache getDownloadDataFromCacheWithRequestUrl:url];</span><br><span class="line">            </span><br><span class="line">            successBlock(downFileUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        NSLog(@&quot;加载完成&quot;);</span><br><span class="line">        </span><br><span class="line">        failureBlock ? failureBlock(error) : 0;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [session resume];</span><br><span class="line">    </span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对下载的数据进行缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  对下载的数据进行缓存</span><br><span class="line"> *</span><br><span class="line"> *  @param data       下载的数据</span><br><span class="line"> *  @param requestUrl 请求url</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> + (void)saveDownloadData:(NSData *)data</span><br><span class="line">              requestUrl:(NSString *)requestUrl &#123;</span><br><span class="line">    assert(data);</span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    NSString *fileName = nil;</span><br><span class="line">    NSString *type = nil;</span><br><span class="line">    NSArray *strArray = nil;</span><br><span class="line">    </span><br><span class="line">    strArray = [requestUrl componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">    if (strArray.count &gt; 0) &#123;</span><br><span class="line">        type = strArray[strArray.count - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (type) &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@.%@&quot;,[self md5:requestUrl],type];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@&quot;,[self md5:requestUrl]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *directoryPath = nil;</span><br><span class="line">    directoryPath = [[NSUserDefaults standardUserDefaults] objectForKey:downloadDirKey];</span><br><span class="line">    if (!directoryPath) &#123;</span><br><span class="line">        directoryPath = [[[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] stringByAppendingPathComponent:@&quot;QCNetworking&quot;] stringByAppendingPathComponent:@&quot;download&quot;];</span><br><span class="line">        </span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setObject:directoryPath forKey:downloadDirKey];</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:directoryPath isDirectory:nil]) &#123;</span><br><span class="line">        [[NSFileManager defaultManager] createDirectoryAtPath:directoryPath withIntermediateDirectories:YES attributes:nil error:&amp;error];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;创建目录错误: %@&quot;,error.localizedDescription);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [directoryPath stringByAppendingPathComponent:fileName];</span><br><span class="line">    </span><br><span class="line">    [[NSFileManager defaultManager] createFileAtPath:filePath contents:data attributes:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取已缓存的下载数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  获取已缓存的下载数据</span><br><span class="line"> *</span><br><span class="line"> *  @param requestUrl 请求url</span><br><span class="line"> *</span><br><span class="line"> *  @return 缓存的url路径</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> + (NSURL *)getDownloadDataFromCacheWithRequestUrl:(NSString *)requestUrl &#123;</span><br><span class="line">    </span><br><span class="line">    assert(requestUrl);</span><br><span class="line">    </span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    NSString *fileName = nil;</span><br><span class="line">    NSString *type = nil;</span><br><span class="line">    NSArray *strArray = nil;</span><br><span class="line">    NSURL *fileUrl = nil;</span><br><span class="line">    </span><br><span class="line">    strArray = [requestUrl componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">    if (strArray.count &gt; 0) &#123;</span><br><span class="line">        type = strArray[strArray.count - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (type) &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@.%@&quot;,[self md5:requestUrl],type];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@&quot;,[self md5:requestUrl]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSString *directoryPath = [[NSUserDefaults standardUserDefaults] objectForKey:downloadDirKey];</span><br><span class="line">    </span><br><span class="line">    if (directoryPath)&#123;</span><br><span class="line">        NSString *filePath = [directoryPath stringByAppendingPathComponent:fileName];</span><br><span class="line">        data = [[NSFileManager defaultManager] contentsAtPath:filePath];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (data) &#123;</span><br><span class="line">        NSString *path = [directoryPath stringByAppendingPathComponent:fileName];</span><br><span class="line">        fileUrl = [NSURL fileURLWithPath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return fileUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体代码实现Github"><a href="#具体代码实现Github" class="headerlink" title="具体代码实现Github"></a>具体代码实现<a href="https://github.com/Joe0708/QCNetworking" target="_blank" rel="noopener">Github</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;p&gt;在开发中我们常常需要向服务器发送请求来获得数据, 正常的流程是这样:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送请求&lt;/li&gt;
&lt;li&gt;网络正常, 将数
      
    
    </summary>
    
      <category term="iOS" scheme="http://joe0708.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://joe0708.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://joe0708.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 性能优化</title>
    <link href="http://joe0708.github.io/2016/09/12/UITableView%20performance%20optimize/"/>
    <id>http://joe0708.github.io/2016/09/12/UITableView performance optimize/</id>
    <published>2016-09-12T03:37:59.000Z</published>
    <updated>2018-01-14T14:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>UITableView是iOS中使用最频繁的控件之一，平常使用过程中我们往往不会注意到其性能优化问题，只有当视图逻辑层次越来越复杂的时候，会导致列表的滑动不是那么流畅, 所有其性能优化也是常常要面对的，尤其是当数据量偏大并且设备性能不足时。那么当我们遇到这个问题时该如何下手呢，本篇文章主要总结和介绍UITableView的性能优化方法，其中一些优化方式是作者在开发中使用过的，有些是总结前人经验，在此总结UITableView的几个性能优化方式</p><h3 id="首先我们分析总结一些影响UITableView性能的几个因素"><a href="#首先我们分析总结一些影响UITableView性能的几个因素" class="headerlink" title="首先我们分析总结一些影响UITableView性能的几个因素:"></a>首先我们分析总结一些影响UITableView性能的几个因素:</h3><ol><li>多种类型cell及过于复杂的视图层级</li><li>cell的高度动态计算</li><li>离屏渲染</li><li>按需加载</li><li>…</li></ol><h4 id="1-视图层级过于复杂"><a href="#1-视图层级过于复杂" class="headerlink" title="1.视图层级过于复杂"></a>1.视图层级过于复杂</h4><p>   由于APP业务越来越复杂分析Cell结构，TableView的视图层级可能越来越复杂，我们可能会用多个cell以应对我们的需求，但是这样也是导致性能下降的原因，所有我们尽可能的将相同内容的抽取到一种样式Cell中，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。好处：</p><blockquote><p>减少代码量，减少Nib文件的数量，统一一个Nib文件定义Cell，容易修改、维护</p></blockquote><p>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为N个。所以如果如果只有一种Cell，那就是只有N个Cell的实例；但是如果有M种Cell，那么运行时最多可能会是“M x N = MN”个Cell的实例，虽然可能并不会占用太多内存，但是能少点不是更好吗。</p><p>，导致性能出现问题，我们在分析cell时，尽量去避免remove、addSubviews 视图, 而是根据逻辑设置视图的hidden隐藏(显示)。在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建、删除要快得多。</p><h4 id="2-cell的高度动态计算"><a href="#2-cell的高度动态计算" class="headerlink" title="2.cell的高度动态计算"></a>2.cell的高度动态计算</h4><p>当cell的每一个cell的高度一样时, 我们可以通过简单的一行代码解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.rowHeight = 88;</span><br></pre></td></tr></table></figure><p>但是如果我们每个cell的高度不一样时, 这时候就需要实现代理方法根据数据返回不一样的高度, 需要注意的是，实现了这个方法后，rowHeight的设置将无效。所以，这个方法适用于具有多种cell高度的UITableView, 行高一样的情况建议你使用前者性能更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    // return xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样我们cell将要出现在屏幕的时候，系统都会去计算cell的高度。导致性能低下，如果说我能通过某种手段，在首次计算的时候，将每个cell对应的高度保存下载，当下次需要用到cell高度的时候再从保存的地方取出，从而减少了计算量，来达到优化的目的。<br>因此应运而生了这套高度缓存的算法的第三方库<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView-FDTemplateLayoutCell</a></p><p>通过第三库在 tableView: heightForRowAtIndexPath: 代理方法中调用以下三个方法之一完成高度获取，从而提高APP性能：*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   identifier 即 cell 的 identifier；</span><br><span class="line">   configuration block 中的代码应与数据源方法 tableView: cellForRowAtIndexPath: 中对 cell 的设置代码相同</span><br><span class="line">   方法内部将根据以上两个参数创建与 cell 对应的 template layout cell，这个 cell 只进行高度计算，不会显示到屏幕上</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 返回计算好的高度(无缓存)</span><br><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifierconfiguration:(void (^)(idcell))configuration;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 返回计算好的高度，并根据 indexPath 内部创建与之相应的二维数组缓存高度</span><br><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifiercacheByIndexPath:(NSIndexPath *)indexPathconfiguration:(void (^)(idcell))configuration;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 返回计算好的高度，内部创建一个字典缓存高度并由使用者指定 key</span><br><span class="line">- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifiercacheByKey:(id&lt;NSCopying&gt;)keyconfiguration:(void (^)(idcell))configuration;</span><br></pre></td></tr></table></figure><h3 id="3-离屏渲染"><a href="#3-离屏渲染" class="headerlink" title="3.离屏渲染"></a>3.离屏渲染</h3><h4 id="GPU渲染机制："><a href="#GPU渲染机制：" class="headerlink" title="GPU渲染机制："></a>GPU渲染机制：</h4><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><h4 id="GPU屏幕渲染有以下两种方式："><a href="#GPU屏幕渲染有以下两种方式：" class="headerlink" title="GPU屏幕渲染有以下两种方式："></a>GPU屏幕渲染有以下两种方式：</h4><ol><li>On-Screen Rendering  意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li><li>Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<blockquote><p>  离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。</p></blockquote></li></ol><h4 id="离屏渲染的触发方式"><a href="#离屏渲染的触发方式" class="headerlink" title="离屏渲染的触发方式"></a>离屏渲染的触发方式</h4><p>设置了以下属性时，都会触发离屏绘</p><ol><li>cornerRadius (圆角）</li><li>masks（遮罩）</li><li>shadows（阴影）</li><li>group opacity（不透明）</li><li>…</li></ol><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换，不管是在GPU渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到On-Screen Rendering或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次mask的渲染操作。</p><p>一次mask发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次mask需要渲染三次才能在屏幕上显示，这已经是普通视图显示3陪耗时，若再加上下文环境切换，一次mask就是普通渲染的30倍以上耗时操作。问我这个30倍以上这个数据怎么的出来的？当我在cell的UIImageView的实例增加到150个，并去掉圆角的时候，帧数才跌至28帧每秒。虽然不是甚准确，但至少反映mask这个耗时是无mask操作的耗时的数十倍的。</p><p>那么如何应对这个问题呢？不要在滚动视图使用cornerRadius或者mask。如果你一定要怎么办呢？那么这样也可以拯救你：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.layer.shouldRasterize = YES;  </span><br><span class="line"></span><br><span class="line">self.layer.rasterizationScale = [UIScreen mainScreen].scale;</span><br></pre></td></tr></table></figure><p>这样大部分情况下可以马上挽救你的帧数在55帧每秒以上。shouldRasterize = YES会使视图渲染内容被缓存起来，下次绘制的时候可以直接显示缓存，当然要在视图内容不改变的情况下，对于复制的视图层次并不建议你这样做。</p><p>还是采取预先生成圆角图片，并缓存起来这个方法才是比较好的手段。预处理圆角图片可以在后台处理，处理完毕后缓存起来，再在主线程显示，这就避免了不必要的离屏渲染了。</p><p>另外也有在图片上面覆盖一个镂空圆形图片的方法可以实现圆形头像效果，这个也是极为高效的方法。缺点就是对视图的背景有要求，单色背景效果就最为理想。</p><h4 id="4-按需加载"><a href="#4-按需加载" class="headerlink" title="4.按需加载"></a>4.按需加载</h4><p>   开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</span><br><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</span><br></pre></td></tr></table></figure><p>   思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     //获取可见部分的Cell</span><br><span class="line">NSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];</span><br><span class="line">        for (NSIndexPath *indexPath in visiblePaths)</span><br><span class="line">        &#123;</span><br><span class="line">        //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载</span><br><span class="line">             &lt;code&gt;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// tableView 停止滑动的时候异步加载图片</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">         if (self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO)</span><br><span class="line">            &#123;</span><br><span class="line">               //开始异步加载图片</span><br><span class="line">                &lt;code&gt;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="最后对性能优化的几点建议"><a href="#最后对性能优化的几点建议" class="headerlink" title="最后对性能优化的几点建议"></a>最后对性能优化的几点建议</h4><ul><li>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；(这个是开发中肯定会要优化的，不可能一个app就几个Cell吧)</li><li>滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage</li><li>异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）</li><li>缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向</li><li>“真机测试，而不是模拟器”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UITableView是iOS中使用最频繁的控件之一，平常使用过程中我们往往不会注意到其性能优化问题，只有当视图逻辑层次越来越复杂的时候，会导致列表的滑动不是那么流畅, 所有其性能优化也是常常要面对的，尤其是当数据量偏大并且设备性能不足时。那么当我们遇到这个问题时该如何下手
      
    
    </summary>
    
      <category term="iOS" scheme="http://joe0708.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://joe0708.github.io/tags/iOS/"/>
    
      <category term="UITableView" scheme="http://joe0708.github.io/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS中几种数据持久化的方案</title>
    <link href="http://joe0708.github.io/2016/09/09/iOS%20data%20persistence/"/>
    <id>http://joe0708.github.io/2016/09/09/iOS data persistence/</id>
    <published>2016-09-09T06:45:28.000Z</published>
    <updated>2018-01-14T14:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我将尝试着介绍一下5种方案：</p><ul><li>plist文件（属性列表）</li><li>preference（偏好设置）</li><li>NSKeyedArchiver（归档）</li><li>SQLite 3</li><li>CoreData</li></ul><h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p><font color="#c10d0c" size="3">1.结构</font><p>既然沙盒就是一个文件夹，那就看看里面有什么吧。沙盒的目录结构如下：</p><ol><li>“应用程序包”</li><li>Documents</li><li>Library</li><li>——-Caches</li><li>——-Preferences</li><li>tmp</li></ol><font color="#c10d0c" size="3">2.目录特性</font><p>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p><p>“应用程序包”: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] bundlePath];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p>Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p> Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line"> NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p>  Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p><p>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSTemporaryDirectory();</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure><p>  <br><br>  <font color="#0099ff" size="3">plist文件</font></p><p>  plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p><p>可以被序列化的类型只有如下几种：</p><ol><li>NSArray</li><li>NSMutableArray</li><li>NSDictionary</li><li>NSMutableDictionary</li><li>NSData</li><li>NSMutableData</li><li>NSString</li><li>NSMutableString</li><li>NSNumber</li><li>NSDate</li></ol><font color="#c10d0c" size="3">1.获得文件路径</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line">   NSString *fileName = [path stringByAppendingPathComponent:@&quot;123.plist&quot;];</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">2.存储</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;123&quot;, @&quot;456&quot;, @&quot;789&quot;];</span><br><span class="line">[array writeToFile:fileName atomically:YES];</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">3.读取</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *result = [NSArray arrayWithContentsOfFile:fileName];</span><br><span class="line">NSLog(@&quot;%@&quot;, result);</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">4.注意</font><ul><li>只有以上列出的类型才能使用plist文件存储。</li><li>存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。</li><li>读取时使用arrayWithContentsOfFile:方法。</li></ul><p><br></p><font color="#0099ff" size="3">Preference</font><br><br><br><br><br><font color="#c10d0c" size="3">1.使用方法</font><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1.获得NSUserDefaults文件</span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">//2.向文件中写入内容</span><br><span class="line">[userDefaults setObject:@&quot;AAA&quot; forKey:@&quot;a&quot;];</span><br><span class="line">[userDefaults setBool:YES forKey:@&quot;sex&quot;];</span><br><span class="line">[userDefaults setInteger:21 forKey:@&quot;age&quot;];</span><br><span class="line">//2.1立即同步</span><br><span class="line">[userDefaults synchronize];</span><br><span class="line">//3.读取文件</span><br><span class="line">NSString *name = [userDefaults objectForKey:@&quot;a&quot;];</span><br><span class="line">BOOL sex = [userDefaults boolForKey:@&quot;sex&quot;];</span><br><span class="line">NSInteger age = [userDefaults integerForKey:@&quot;age&quot;];</span><br><span class="line">NSLog(@&quot;%@, %d, %ld&quot;, name, sex, age);</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">2.注意</font><ul><li>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。 </li><li>如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。</li><li>偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</li></ul><p><br></p><font color="#0099ff" size="3">NSKeyedArchiver</font><p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p><font color="#c10d0c" size="3">1.遵循NSCoding协议</font><p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p><ul><li>遵循协议和设置属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.遵循NSCoding协议 </span><br><span class="line">@interface Person : NSObject   //2.设置属性</span><br><span class="line">@property (strong, nonatomic) UIImage *avatar;</span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line">@property (assign, nonatomic) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>实现协议方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  //解档</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if ([super init]) &#123;</span><br><span class="line">        self.avatar = [aDecoder decodeObjectForKey:@&quot;avatar&quot;];</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">        self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//归档</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:self.avatar forKey:@&quot;avatar&quot;];</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>特别注意</p><p>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 <strong>[super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder]</strong> 方法;</p></li></ul><font color="#c10d0c" size="3">2.使用</font><p>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.avatar = self.avatarView.image;</span><br><span class="line">person.name = self.nameField.text;</span><br><span class="line">person.age = [self.ageField.text integerValue];</span><br><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:file];</span><br></pre></td></tr></table></figure><p>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];</span><br><span class="line">if (person) &#123;</span><br><span class="line">   self.avatarView.image = person.avatar;</span><br><span class="line">   self.nameField.text = person.name;</span><br><span class="line">   self.ageField.text = [NSString stringWithFormat:@&quot;%ld&quot;, person.age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">3.注意</font><ul><li>必须遵循并实现NSCoding协议</li><li>保存文件的扩展名可以任意指定</li><li>继承时必须先调用父类的归档解档方法</li></ul><p><br></p><font color="#0099ff" size="3">SQLite3</font><p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p><font color="#c10d0c" size="3">1.字段类型</font><p>表面上SQLite将数据分为以下几种类型：</p><ul><li>integer : 整数</li><li>real : 实数（浮点数）</li><li>text : 文本字符串</li><li>blob : 二进制数据，比如文件，图片之类的</li></ul><p>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！<strong>主键必须设置成integer</strong></p><font color="#c10d0c" size="3">2. 准备工作</font><p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p><font color="#c10d0c" size="3">3.使用</font><ul><li>创建数据库并打开</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  打开数据库并创建一个表</span><br><span class="line">*/</span><br><span class="line">- (void)openDatabase &#123;</span><br><span class="line">   //1.设置文件名</span><br><span class="line">   NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span><br><span class="line">   //2.打开数据库文件，如果没有会自动创建一个文件</span><br><span class="line">   NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</span><br><span class="line">   if (result == SQLITE_OK) &#123;</span><br><span class="line">       NSLog(@&quot;打开数据库成功！&quot;);</span><br><span class="line">       //3.创建一个数据库表</span><br><span class="line">       char *errmsg = NULL;</span><br><span class="line">       sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">       if (errmsg) &#123;</span><br><span class="line">           NSLog(@&quot;错误：%s&quot;, errmsg);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           NSLog(@&quot;创表成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       NSLog(@&quot;打开数据库失败！&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行指令</li></ul><p>使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  往表中插入1000条数据</span><br><span class="line">*/</span><br><span class="line">- (void)insertData &#123;</span><br><span class="line">NSString *nameStr;</span><br><span class="line">NSInteger age;</span><br><span class="line">for (NSInteger i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  nameStr = [NSString stringWithFormat:@&quot;Bourne-%d&quot;, arc4random_uniform(10000)];</span><br><span class="line">  age = arc4random_uniform(80) + 20;</span><br><span class="line">  NSString *sql = [NSString stringWithFormat:@&quot;INSERT INTO t_person (name, age) VALUES(&apos;%@&apos;, &apos;%ld&apos;)&quot;, nameStr, age];</span><br><span class="line">  char *errmsg = NULL;</span><br><span class="line">  sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg);</span><br><span class="line">  if (errmsg) &#123;</span><br><span class="line">      NSLog(@&quot;错误：%s&quot;, errmsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;插入完毕！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询指令</li></ul><p>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p><ol><li>sqlite3_prepare_v2() : 检查sql的合法性</li><li>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</li><li>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</li><li>sqlite3_finalize() : 释放stmt</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  从表中读取数据到数组中</span><br><span class="line">*/</span><br><span class="line">- (void)readData &#123;</span><br><span class="line">   NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000];</span><br><span class="line">   char *sql = &quot;select name, age from t_person;&quot;;</span><br><span class="line">   sqlite3_stmt *stmt;</span><br><span class="line">   NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL);</span><br><span class="line">   if (result == SQLITE_OK) &#123;</span><br><span class="line">       while (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">           char *name = (char *)sqlite3_column_text(stmt, 0);</span><br><span class="line">           NSInteger age = sqlite3_column_int(stmt, 1);</span><br><span class="line">           //创建对象</span><br><span class="line">           Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age];</span><br><span class="line">           [mArray addObject:person];</span><br><span class="line">       &#125;</span><br><span class="line">       self.dataList = mArray;</span><br><span class="line">   &#125;</span><br><span class="line">   sqlite3_finalize(stmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">4.总结</font><p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p><p><br></p><font color="#0099ff" size="3">FMDB</font><br><br><br><br><br><font color="#c10d0c" size="3">1.简介</font><p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p><ul><li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li><li>对比苹果自带的Core Data框架，更加轻量级和灵活</li><li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li><li>注：<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB的gitHub地址</a></li></ul><font color="#c10d0c" size="3">2.核心类</font><p>FMDB有三个主要的类：</p><ul><li>FMDatabase</li></ul><p>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p><ul><li>FMResultSet</li></ul><p>使用FMDatabase执行查询后的结果集</p><ul><li>FMDatabaseQueue</li></ul><p>用于在多线程中执行多个查询或更新，它是线程安全的</p><font color="#c10d0c" size="3">3.打开数据库</font><p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span><br><span class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </span><br><span class="line">if (![database open]) &#123;</span><br><span class="line">    NSLog(@&quot;数据库打开失败！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，Path的值可以传入以下三种情况：</p><ul><li>具体文件路径，如果不存在会自动创建</li><li>空字符串@””，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li><li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li></ul><font color="#c10d0c" size="3">4.更新</font><p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//常用方法有以下3种：   </span><br><span class="line">- (BOOL)executeUpdate:(NSString*)sql, ...</span><br><span class="line">- (BOOL)executeUpdateWithFormat:(NSString*)format, ...</span><br><span class="line">- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments</span><br><span class="line">//示例</span><br><span class="line">[database executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;];   </span><br><span class="line">//或者  </span><br><span class="line">[database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES(?, ?)&quot;, @&quot;Bourne&quot;, [NSNumber numberWithInt:42]];</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">5.查询</font><p>查询方法也有3种，使用起来相当简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(NSString*)sql, ...</span><br><span class="line">- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</span><br><span class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</span><br></pre></td></tr></table></figure><p>查询示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.执行查询</span><br><span class="line">FMResultSet *result = [database executeQuery:@&quot;SELECT * FROM t_person&quot;];</span><br><span class="line">//2.遍历结果集</span><br><span class="line">while ([result next]) &#123;</span><br><span class="line">    NSString *name = [result stringForColumn:@&quot;name&quot;];</span><br><span class="line">    int age = [result intForColumn:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#c10d0c" size="3">6.线程安全</font><p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p><ul><li>创建队列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</span><br></pre></td></tr></table></figure><ul><li>使用队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_1&quot;, [NSNumber numberWithInt:1]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_2&quot;, [NSNumber numberWithInt:2]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_3&quot;, [NSNumber numberWithInt:3]];      </span><br><span class="line">          FMResultSet *result = [database executeQuery:@&quot;select * from t_person&quot;];    </span><br><span class="line">         while([result next]) &#123;   </span><br><span class="line">         &#125;    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>而且可以轻松地把简单任务包装到事务里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *database, BOOL *rollback) &#123;    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_1&quot;, [NSNumber numberWithInt:1]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_2&quot;, [NSNumber numberWithInt:2]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_3&quot;, [NSNumber numberWithInt:3]];      </span><br><span class="line">          FMResultSet *result = [database executeQuery:@&quot;select * from t_person&quot;];    </span><br><span class="line">             while([result next]) &#123;   </span><br><span class="line">             &#125;   </span><br><span class="line">           //回滚</span><br><span class="line">           *rollback = YES;  </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; class=&quot;headerlink&quot; title=&quot;概论&quot;&gt;&lt;/a&gt;概论&lt;/h2&gt;&lt;p&gt;所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我
      
    
    </summary>
    
      <category term="iOS" scheme="http://joe0708.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://joe0708.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>为自己的开源库添加对CocoaPods的支持</title>
    <link href="http://joe0708.github.io/2016/09/07/CocoaPods/"/>
    <id>http://joe0708.github.io/2016/09/07/CocoaPods/</id>
    <published>2016-09-07T01:34:00.000Z</published>
    <updated>2018-01-14T14:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为iOS开发者, 我们常常会用到第三方开源库, 并利用CocoaPods管理第三方库,并且非常方便,简单的执行 <code>pod install</code> 命令即可将第三方库导入到我们的项目中</p><p>如果我们想将自己的开源库提供给别人用, 让别人也可以简单集成自己的开源库, 该如何做呢?<br>下面给大家演示如何将自己的开源库添加对CocoaPods的支持, 我将步骤分为三步:</p><ol><li>注册trunk</li><li>配置 podspec 描述文件</li><li>将 podspec 推送到 CocoaPods</li></ol><p><br><br><br><br></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>trunk对CocoaPods的版本有要求, 需要保证CocoaPods在0.33及以上版本,你可以同过 <code>pod --version</code> 查看当前版本</p><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f7ks9ps8fzj209i02a0ss.jpg" alt="image"></p><p>如果您的版本低于0.33就需要通过gem命令更新CocoaPods;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="一、-注册trunk"><a href="#一、-注册trunk" class="headerlink" title="一、 注册trunk"></a>一、 注册trunk</h2><p>打开终端输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 你的邮箱 &apos;你的用户名&apos;</span><br></pre></td></tr></table></figure><p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f7ksgfah9qj20de01oq35.jpg" alt="image"></p><p>等待命令执行完毕,CocoaPods会给你发送一封邮箱进行验证</p><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f7ksi422w9j20e305j3yx.jpg" alt="image"></p><p>复制邮件中的链接到浏览器中打开即可验证,出现如下提示就代表验证成功</p><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f7kskv007aj20j909et99.jpg" alt="image"></p><p>现在我们可以通过以下命令从终端查看自己的注册信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f7ksn4amzzj20eb06sgms.jpg" alt="image"></p><p>至此代表你已经注册成功</p><p>   <br><br><br></p><h2 id="二、-配置-podspec-描述文件"><a href="#二、-配置-podspec-描述文件" class="headerlink" title="二、 配置 podspec 描述文件"></a>二、 配置 podspec 描述文件</h2><p>podspec为Pods依赖库的描述文件, 每个Pods依赖库必须有切仅有一个描述文件, 文件名称必须和我们的开源库名称一致,该文件中描述的开源库的一样详细信息和依赖框架<br><br><br></p><h3 id="创建-podspec-文件"><a href="#创建-podspec-文件" class="headerlink" title="创建 podspec 文件"></a>创建 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create 你的podspec文件的文件名(开源库的名称)</span><br></pre></td></tr></table></figure><p>这样就生成了podspec文件，接下来就是需要编辑podspec文件里面的内容，打开文件会发现里面的内容很多, 很多都是我们不需要关心，我们只需要填写一些必须的内容即可, 你可以直接复制下面的podspec文件,改一些你自己相关的内容即可, 或者直接在github上找开源库,复制它的podspec信息即可</p><p>podspec文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         = &quot;QCCountdownButton&quot;</span><br><span class="line">  s.version      = &quot;1.0&quot;</span><br><span class="line">  s.summary      = &quot;Countdown Button For iOS&quot;</span><br><span class="line">  s.homepage     = &quot;https://github.com/Joe0708/QCCountdownButton&quot;</span><br><span class="line">  s.license      = &quot;Copyright (c) 2016年 Joe. All rights reserved.&quot;</span><br><span class="line">  s.author       = &#123; &quot;Joe&quot; =&gt; &quot;joesir7@foxmail.com&quot; &#125;</span><br><span class="line">  s.platform     = :ios, &quot;7.0&quot;</span><br><span class="line">  s.ios.deployment_target = &quot;7.0&quot;</span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/Joe0708/QCCountdownButton.git&quot;, :tag =&gt; s.version &#125;</span><br><span class="line">  s.source_files  = &quot;QCCountdownButton/QCCountdownButton/*.*&quot;</span><br><span class="line">  s.requires_arc = true</span><br><span class="line">  # s.frameworks = &apos;SomeFramework&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>s.name     开源库的名称</p><p>s.version 版本号</p><p>s.summary 库简介</p><p>s.homepage 库的主页</p><p>s.license 授权版本</p><p>s.author 库的作者</p><p>s.platform 支持的平台</p><p>s.ios.deployment_target 最低支持系统</p><p>s.source 源代码链接</p><p>s.source_files 库的源代码位置</p><p>s.requires_arc 是否ARC</p><p>s.frameworks 开源库中依赖的其他库(如果你有依  赖其他库, 需要在这里声明, 如果没有可忽略)</p></blockquote><p>配置完podspec文件后, 我们需要对podspec文件进行验证其是否编写正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint 库名字.podspec</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f7ktelxocoj20fw04xgmi.jpg" alt="image"></p><p>你可能会遇到以下错误,提示找不到license文件,这个我们可以使用<code>--allow-warnings</code>命令进行忽略(<code>--verbose</code>查看详细信息)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint 库名字.podspec --allow-warnings</span><br></pre></td></tr></table></figure><p>看到<code>QCCountdownButton.podspec passed validation.</code>即代表验证通过</p><p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f7ktgtwlkzj20ft052gmd.jpg" alt="image"></p><p><br><br><br><br></p><h2 id="三、-将-podspec-推送到-CocoaPods"><a href="#三、-将-podspec-推送到-CocoaPods" class="headerlink" title="三、 将 podspec 推送到 CocoaPods"></a>三、 将 podspec 推送到 CocoaPods</h2><p>podspec验证通过后, 我们就可以将 podspec 推送到 CocoaPods</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push QCCountdownButton.podspec</span><br></pre></td></tr></table></figure><p>最后我们可以通过 <code>pod search 库名称</code> 来查找自己的开源库</p><p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f7ktm43594j20fk040wf2.jpg" alt="image"></p><p>至此开源库已经上传至CocoaPods, 别人可以直接通过CocoaPods安装你的开源库</p><p>如果<code>pod search</code>无法搜索到自己的库,可以执行<code>pod setup</code>命令进行更新</p><p><br><br><br><br><br></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><br><br>开源库发布之后, 我们需要给开源库打上tag, tag和podspec文件中的tag保持一致,否则会提示找不到对应的库<br>顺便为自己的开源库打个广告 <a href="https://github.com/Joe0708/QCCountdownButton" target="_blank" rel="noopener">QCCountdownButton</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为iOS开发者, 我们常常会用到第三方开源库, 并利用CocoaPods管理第三方库,并且非常方便,简单的执行 &lt;code&gt;pod install&lt;/code&gt; 命令即可将第三方库导入到我们的项目中&lt;/p&gt;
&lt;p&gt;如果我们想将自己的开源库提供给别人用, 让别人也可以简单集
      
    
    </summary>
    
      <category term="iOS" scheme="http://joe0708.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://joe0708.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://joe0708.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>如何排查 message sent to deallocated instance 问题</title>
    <link href="http://joe0708.github.io/2016/09/06/message%20sent%20to%20deallocated%20instance/"/>
    <id>http://joe0708.github.io/2016/09/06/message sent to deallocated instance/</id>
    <published>2016-09-06T02:04:10.000Z</published>
    <updated>2018-01-14T14:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于开发者来说, 遇到这种问题是很难排查的, 没有堆栈信息, 不知从和查起,今天项目过程中遇到这个问题,脑袋那个头大. 不过最后还是在网上找到的排查方案,在这里做个笔记</p><blockquote><p>编译器环境:Xcode 7.3.2</p><p>运行环境  : 模拟器 (貌似真机不支持, 没试过)</p></blockquote><p>当我们的对象被销毁时, 再发送消息就会导致野指针错误, 而控制台也没有任何输入, 如下提示</p><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/52656420313-35e08fe121255270.jpg" alt="image"></p><p>遇到这种问题, 会一头雾水不知如何解决,别急,下面跟着我一步步排查问题</p><p>首页我们打开Xcode的僵尸对象(Zombie Objects), 点击我们的项目并选择 “Edit Scheme…” ,如图</p><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/1525420313-b50cb26e90aa22a4.jpg" alt="image"></p><p>然后点击 Diagnostics, 勾选 Enable Zombie Objects ,如图</p><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/147312764359081.jpg?imageView2/0/format/jpg" alt="image"></p><p>重新运行项目,重现刚才导致野指针的的问题,现在奔溃时控制台就会有一条奔溃信息</p><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/147312767036825.jpg?imageView2/0/format/jpg" alt="image"></p><p>但是得到这个, 我们还是没法排查问题, 别急, 我们先把上图中的内存地址存起来 , 也就是 : 0x7f8ed30bedd0</p><p>我们打开系统自带的活动监视器, 并在搜索按钮中输入您的项目名称,例如我的叫 “naL”, 那我就搜索 “nal”, 我们会得到一条进程,我们需要其中的 “PID” 信息</p><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/14731276998473.jpg?imageView2/0/format/jpg" alt="image"></p><p>现在我们得到如下信息</p><blockquote><p>进程ID：31029</p><p>崩溃地址：0x7f8ed30bedd0</p></blockquote><p>接下来我们打开终端，输入以下命令：</p><blockquote><p>sudo malloc_history 31029 0x7f8ed30bedd0</p></blockquote><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/147312778931138.jpg?imageView2/0/format/jpg" alt="image"></p><p>图中红色划线的地方就是最后调用导致奔溃的地方,我们根据这个线索就可以查到问题根源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于开发者来说, 遇到这种问题是很难排查的, 没有堆栈信息, 不知从和查起,今天项目过程中遇到这个问题,脑袋那个头大. 不过最后还是在网上找到的排查方案,在这里做个笔记&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器环境:Xcode 7.3.2&lt;/p&gt;
&lt;p&gt;运行环境  :
      
    
    </summary>
    
      <category term="iOS" scheme="http://joe0708.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://joe0708.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
