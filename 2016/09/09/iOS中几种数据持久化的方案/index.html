<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>iOS中几种数据持久化的方案 | Joe</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="joe, ios developer, Python, php, 程序员, 全栈工程师"><meta name="description" content="日常学习、生活及工作的一些心得记录"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://joe0708.github.io/2016/09/09/iOS中几种数据持久化的方案/index.html"><link rel="icon" type="image/png" href="http://ojpb4w81b.bkt.clouddn.com/18-1-15/70545015.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Joe"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Joe" alt="Joe"><img src="http://ojpb4w81b.bkt.clouddn.com/18-1-14/88417485.jpg" alt="Joe"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="http://ojpb4w81b.bkt.clouddn.com/18-1-14/35182701.jpg" alt="iOS中几种数据持久化的方案"></div><header class="post__info"><h1 class="post__title">iOS中几种数据持久化的方案</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/Joe0708">Joe</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2016-09-09</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/iOS/">iOS</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我将尝试着介绍一下5种方案：</p><ul><li>plist文件（属性列表）</li><li>preference（偏好设置）</li><li>NSKeyedArchiver（归档）</li><li>SQLite 3</li><li>CoreData</li></ul><h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p><font color="#c10d0c" size="3">1.结构</font><p>既然沙盒就是一个文件夹，那就看看里面有什么吧。沙盒的目录结构如下：</p><ol><li>“应用程序包”</li><li>Documents</li><li>Library</li><li>——-Caches</li><li>——-Preferences</li><li>tmp</li></ol><font color="#c10d0c" size="3">2.目录特性</font><p>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p><p>“应用程序包”: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] bundlePath];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure>
<p>Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure>
<p> Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line"> NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure>
<p>  Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p>
<p>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSTemporaryDirectory();</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, path);</span><br></pre></td></tr></table></figure>
<p>  <br><br>  <font color="#0099ff" size="3">plist文件</font></p>
<p>  plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p>
<p>可以被序列化的类型只有如下几种：</p>
<ol>
<li>NSArray</li>
<li>NSMutableArray</li>
<li>NSDictionary</li>
<li>NSMutableDictionary</li>
<li>NSData</li>
<li>NSMutableData</li>
<li>NSString</li>
<li>NSMutableString</li>
<li>NSNumber</li>
<li>NSDate</li>
</ol>
<font color="#c10d0c" size="3">1.获得文件路径</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line">   NSString *fileName = [path stringByAppendingPathComponent:@&quot;123.plist&quot;];</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">2.存储</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;123&quot;, @&quot;456&quot;, @&quot;789&quot;];</span><br><span class="line">[array writeToFile:fileName atomically:YES];</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">3.读取</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *result = [NSArray arrayWithContentsOfFile:fileName];</span><br><span class="line">NSLog(@&quot;%@&quot;, result);</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">4.注意</font>

<ul>
<li>只有以上列出的类型才能使用plist文件存储。</li>
<li>存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。</li>
<li>读取时使用arrayWithContentsOfFile:方法。</li>
</ul>
<p><br></p>
<font color="#0099ff" size="3">Preference</font><br><br><br><br><br><font color="#c10d0c" size="3">1.使用方法</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1.获得NSUserDefaults文件</span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">//2.向文件中写入内容</span><br><span class="line">[userDefaults setObject:@&quot;AAA&quot; forKey:@&quot;a&quot;];</span><br><span class="line">[userDefaults setBool:YES forKey:@&quot;sex&quot;];</span><br><span class="line">[userDefaults setInteger:21 forKey:@&quot;age&quot;];</span><br><span class="line">//2.1立即同步</span><br><span class="line">[userDefaults synchronize];</span><br><span class="line">//3.读取文件</span><br><span class="line">NSString *name = [userDefaults objectForKey:@&quot;a&quot;];</span><br><span class="line">BOOL sex = [userDefaults boolForKey:@&quot;sex&quot;];</span><br><span class="line">NSInteger age = [userDefaults integerForKey:@&quot;age&quot;];</span><br><span class="line">NSLog(@&quot;%@, %d, %ld&quot;, name, sex, age);</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">2.注意</font>

<ul>
<li>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。 </li>
<li>如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。</li>
<li>偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</li>
</ul>
<p><br></p>
<font color="#0099ff" size="3">NSKeyedArchiver</font>

<p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>
<font color="#c10d0c" size="3">1.遵循NSCoding协议</font>

<p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>
<ul>
<li>遵循协议和设置属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.遵循NSCoding协议 </span><br><span class="line">@interface Person : NSObject   //2.设置属性</span><br><span class="line">@property (strong, nonatomic) UIImage *avatar;</span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line">@property (assign, nonatomic) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>实现协议方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  //解档</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if ([super init]) &#123;</span><br><span class="line">        self.avatar = [aDecoder decodeObjectForKey:@&quot;avatar&quot;];</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">        self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//归档</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:self.avatar forKey:@&quot;avatar&quot;];</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>特别注意</p>
<p>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 <strong>[super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder]</strong> 方法;</p>
</li>
</ul>
<font color="#c10d0c" size="3">2.使用</font>

<p>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.avatar = self.avatarView.image;</span><br><span class="line">person.name = self.nameField.text;</span><br><span class="line">person.age = [self.ageField.text integerValue];</span><br><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:file];</span><br></pre></td></tr></table></figure>
<p>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];</span><br><span class="line">if (person) &#123;</span><br><span class="line">   self.avatarView.image = person.avatar;</span><br><span class="line">   self.nameField.text = person.name;</span><br><span class="line">   self.ageField.text = [NSString stringWithFormat:@&quot;%ld&quot;, person.age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">3.注意</font>

<ul>
<li>必须遵循并实现NSCoding协议</li>
<li>保存文件的扩展名可以任意指定</li>
<li>继承时必须先调用父类的归档解档方法</li>
</ul>
<p><br></p>
<font color="#0099ff" size="3">SQLite3</font>


<p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>
<font color="#c10d0c" size="3">1.字段类型</font>

<p>表面上SQLite将数据分为以下几种类型：</p>
<ul>
<li>integer : 整数</li>
<li>real : 实数（浮点数）</li>
<li>text : 文本字符串</li>
<li>blob : 二进制数据，比如文件，图片之类的</li>
</ul>
<p>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！<strong>主键必须设置成integer</strong></p>
<font color="#c10d0c" size="3">2. 准备工作</font>

<p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>
<font color="#c10d0c" size="3">3.使用</font>

<ul>
<li>创建数据库并打开</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  打开数据库并创建一个表</span><br><span class="line">*/</span><br><span class="line">- (void)openDatabase &#123;</span><br><span class="line">   //1.设置文件名</span><br><span class="line">   NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span><br><span class="line">   //2.打开数据库文件，如果没有会自动创建一个文件</span><br><span class="line">   NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</span><br><span class="line">   if (result == SQLITE_OK) &#123;</span><br><span class="line">       NSLog(@&quot;打开数据库成功！&quot;);</span><br><span class="line">       //3.创建一个数据库表</span><br><span class="line">       char *errmsg = NULL;</span><br><span class="line">       sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">       if (errmsg) &#123;</span><br><span class="line">           NSLog(@&quot;错误：%s&quot;, errmsg);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           NSLog(@&quot;创表成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       NSLog(@&quot;打开数据库失败！&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行指令</li>
</ul>
<p>使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  往表中插入1000条数据</span><br><span class="line">*/</span><br><span class="line">- (void)insertData &#123;</span><br><span class="line">NSString *nameStr;</span><br><span class="line">NSInteger age;</span><br><span class="line">for (NSInteger i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  nameStr = [NSString stringWithFormat:@&quot;Bourne-%d&quot;, arc4random_uniform(10000)];</span><br><span class="line">  age = arc4random_uniform(80) + 20;</span><br><span class="line">  NSString *sql = [NSString stringWithFormat:@&quot;INSERT INTO t_person (name, age) VALUES(&apos;%@&apos;, &apos;%ld&apos;)&quot;, nameStr, age];</span><br><span class="line">  char *errmsg = NULL;</span><br><span class="line">  sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg);</span><br><span class="line">  if (errmsg) &#123;</span><br><span class="line">      NSLog(@&quot;错误：%s&quot;, errmsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;插入完毕！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询指令</li>
</ul>
<p>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p>
<ol>
<li>sqlite3_prepare_v2() : 检查sql的合法性</li>
<li>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</li>
<li>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</li>
<li>sqlite3_finalize() : 释放stmt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  从表中读取数据到数组中</span><br><span class="line">*/</span><br><span class="line">- (void)readData &#123;</span><br><span class="line">   NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000];</span><br><span class="line">   char *sql = &quot;select name, age from t_person;&quot;;</span><br><span class="line">   sqlite3_stmt *stmt;</span><br><span class="line">   NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL);</span><br><span class="line">   if (result == SQLITE_OK) &#123;</span><br><span class="line">       while (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">           char *name = (char *)sqlite3_column_text(stmt, 0);</span><br><span class="line">           NSInteger age = sqlite3_column_int(stmt, 1);</span><br><span class="line">           //创建对象</span><br><span class="line">           Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age];</span><br><span class="line">           [mArray addObject:person];</span><br><span class="line">       &#125;</span><br><span class="line">       self.dataList = mArray;</span><br><span class="line">   &#125;</span><br><span class="line">   sqlite3_finalize(stmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">4.总结</font>

<p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>
<p><br></p>
<font color="#0099ff" size="3">FMDB</font><br><br><br><br><br><font color="#c10d0c" size="3">1.简介</font>


<p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>
<ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的Core Data框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
<li>注：<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB的gitHub地址</a></li>
</ul>
<font color="#c10d0c" size="3">2.核心类</font>

<p>FMDB有三个主要的类：</p>
<ul>
<li>FMDatabase</li>
</ul>
<p>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p>
<ul>
<li>FMResultSet</li>
</ul>
<p>使用FMDatabase执行查询后的结果集</p>
<ul>
<li>FMDatabaseQueue</li>
</ul>
<p>用于在多线程中执行多个查询或更新，它是线程安全的</p>
<font color="#c10d0c" size="3">3.打开数据库</font>

<p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;];</span><br><span class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </span><br><span class="line">if (![database open]) &#123;</span><br><span class="line">    NSLog(@&quot;数据库打开失败！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，Path的值可以传入以下三种情况：</p>
<ul>
<li>具体文件路径，如果不存在会自动创建</li>
<li>空字符串@””，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li>
<li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
<font color="#c10d0c" size="3">4.更新</font>

<p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//常用方法有以下3种：   </span><br><span class="line">- (BOOL)executeUpdate:(NSString*)sql, ...</span><br><span class="line">- (BOOL)executeUpdateWithFormat:(NSString*)format, ...</span><br><span class="line">- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments</span><br><span class="line">//示例</span><br><span class="line">[database executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;];   </span><br><span class="line">//或者  </span><br><span class="line">[database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES(?, ?)&quot;, @&quot;Bourne&quot;, [NSNumber numberWithInt:42]];</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">5.查询</font>

<p>查询方法也有3种，使用起来相当简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(NSString*)sql, ...</span><br><span class="line">- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</span><br><span class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</span><br></pre></td></tr></table></figure>
<p>查询示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.执行查询</span><br><span class="line">FMResultSet *result = [database executeQuery:@&quot;SELECT * FROM t_person&quot;];</span><br><span class="line">//2.遍历结果集</span><br><span class="line">while ([result next]) &#123;</span><br><span class="line">    NSString *name = [result stringForColumn:@&quot;name&quot;];</span><br><span class="line">    int age = [result intForColumn:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#c10d0c" size="3">6.线程安全</font>

<p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>
<ul>
<li>创建队列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</span><br></pre></td></tr></table></figure>
<ul>
<li>使用队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_1&quot;, [NSNumber numberWithInt:1]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_2&quot;, [NSNumber numberWithInt:2]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_3&quot;, [NSNumber numberWithInt:3]];      </span><br><span class="line">          FMResultSet *result = [database executeQuery:@&quot;select * from t_person&quot;];    </span><br><span class="line">         while([result next]) &#123;   </span><br><span class="line">         &#125;    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>而且可以轻松地把简单任务包装到事务里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *database, BOOL *rollback) &#123;    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_1&quot;, [NSNumber numberWithInt:1]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_2&quot;, [NSNumber numberWithInt:2]];    </span><br><span class="line">          [database executeUpdate:@&quot;INSERT INTO t_person(name, age) VALUES (?, ?)&quot;, @&quot;Bourne_3&quot;, [NSNumber numberWithInt:3]];      </span><br><span class="line">          FMResultSet *result = [database executeQuery:@&quot;select * from t_person&quot;];    </span><br><span class="line">             while([result next]) &#123;   </span><br><span class="line">             &#125;   </span><br><span class="line">           //回滚</span><br><span class="line">           *rollback = YES;  </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>


        
        <div class="post-announce">
            感谢您的阅读，本文由
            <a href="http://joe0708.github.io">Joe</a>
            版权所有。如若转载，请注明出处：Joe（<a href="http://joe0708.github.io/2016/09/09/iOS中几种数据持久化的方案/">http://joe0708.github.io/2016/09/09/iOS中几种数据持久化的方案/</a>）
        </div>
        

        <div class="post__prevs">
            <div class="post__prev">
                
                <a href="/2016/09/07/为自己的开源库添加对CocoaPods的支持/" title="为自己的开源库添加对CocoaPods的支持"><i class="iconfont icon-prev"></i>为自己的开源库添加对CocoaPods的支持</a>
                
            </div>
            <div class="post__prev post__prev--right">
                
                <a href="/2016/09/12/UITableView-性能优化/" title="UITableView 性能优化">UITableView 性能优化<i class="iconfont icon-next"></i></a>
                
            </div>
        </div>
    </div>
</article>

        
            <div id="comment-container"></div>
        
        
    </div>

    <aside class="page__sidebar">
    

    <form id="page-search-from" class="page__search-from" action="/search/">
        <label class="search-form__item">
            <input class="input" type="text" name="search" placeholder="Search...">
            <i class="iconfont icon-search"></i>
        </label>
    </form>

    
        <div class="sidebar__block">
            <h3 class="block__title">简介</h3>
            <p class="block__text">日常学习、生活及工作的一些心得记录</p>
        </div>
    

    <div class="sidebar__block">
        <h3 class="block__title">文章分类</h3>
        <ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/软件/">软件</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/macOS/">macOS</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/iOS/">iOS</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Python/">Python</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/PHP/">PHP</a><span class="block-list-count">3</span></li></ul>
    </div>
    
    <div class="sidebar__block">
        <h3 class="block__title">最新文章</h3>
        
        <ul class="block-list latest-post-list">
            
                    <li class="latest-post-item">
                        <a href="/2018/01/13/在-macOS-上更优雅的使用答题辅助脚本/" title="在 macOS 上更优雅的使用答题辅助脚本">
                            <div class="item__cover">
                                <img src="https://camo.githubusercontent.com/45ccd3ace056bcbfa470f743bef02d1af380d7a1/687474703a2f2f6f6a706234773831622e626b742e636c6f7564646e2e636f6d2f31382d312d31322f38343638343436332e6a7067" alt="在 macOS 上更优雅的使用答题辅助脚本">
                            </div>
                            <div class="item__info">
                                <h3 class="item__title">在 macOS 上更优雅的使用答题辅助脚本</h3>
                                <span class="item__text">2018-01-13</span>
                            </div>
                        </a>
                    </li>
                
                    <li class="latest-post-item">
                        <a href="/2018/01/05/Vim-复习笔记/" title="Vim 复习笔记">
                            <div class="item__cover">
                                <img src="http://ojpb4w81b.bkt.clouddn.com/18-1-15/38008852.jpg" alt="Vim 复习笔记">
                            </div>
                            <div class="item__info">
                                <h3 class="item__title">Vim 复习笔记</h3>
                                <span class="item__text">2018-01-05</span>
                            </div>
                        </a>
                    </li>
                
                    <li class="latest-post-item">
                        <a href="/2018/01/05/重新学-Linux-命令/" title="重新学 Linux 命令">
                            <div class="item__cover">
                                <img src="http://ojpb4w81b.bkt.clouddn.com/18-1-15/74981402.jpg" alt="重新学 Linux 命令">
                            </div>
                            <div class="item__info">
                                <h3 class="item__title">重新学 Linux 命令</h3>
                                <span class="item__text">2018-01-05</span>
                            </div>
                        </a>
                    </li>
                
                    <li class="latest-post-item">
                        <a href="/2017/12/23/fastlane-boarding-实践笔记/" title="fastlane boarding 实践笔记">
                            <div class="item__cover">
                                <img src="http://ojpb4w81b.bkt.clouddn.com/18-1-15/5196198.jpg" alt="fastlane boarding 实践笔记">
                            </div>
                            <div class="item__info">
                                <h3 class="item__title">fastlane boarding 实践笔记</h3>
                                <span class="item__text">2017-12-23</span>
                            </div>
                        </a>
                    </li>
                
        </ul>
    
    </div>

    <div class="sidebar__block">
        <h3 class="block__title">文章标签</h3>
        
        <ul class="block-list tag-list clearfix">
            
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/Chromium/">Chromium</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/CocoaPods/">CocoaPods</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/CrossOver/">CrossOver</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/Linux/">Linux</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/MySQL/">MySQL</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/PHP/">PHP</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/Python/">Python</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/SQL/">SQL</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/UITableView/">UITableView</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/Vim/">Vim</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/fastlane/">fastlane</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/iOS/">iOS</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/macOS/">macOS</a>
                    </li>  
                
                    <li class="tag-item">
                        <a class="tag-link" href="/tags/脚本/">脚本</a>
                    </li>  
                
        </ul>
    
    </div>

    
</aside>
</main>


        
            
<footer class="page__footer">
    <section class="footer__top">
        <div class="page__container footer__container">
            
            <div class="footer-top__item footer-top__item--2">
                <h3 class="item__title">关于</h3>
                <div class="item__content">
                    <p class="item__text">分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p>
                    <ul class="footer__contact-info">
                        <li class="contact-info__item">
                            <i class="iconfont icon-address"></i>
                            <span>Guangzhou, Guangdong Province, China</span>
                        </li>
                        <li class="contact-info__item">
                            <i class="iconfont icon-email2"></i>
                            <span>aidevjoe@gmail.com</span>
                        </li>
                    </ul>
                </div>
            </div>

            
            
                <div class="footer-top__item footer__image">
                    <img src="http://ojpb4w81b.bkt.clouddn.com/18-1-15/12385169.jpg" alt="logo" title="Joe">
                </div>
            
            
            
            
        </div>
    </section>
    <section class="footer__bottom">
        <div class="page__container footer__container">
            <p class="footer__copyright">©
                <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by
                <a href="http://hexo.io/" target="_blank">Hexo</a>, made by 
                <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.
            </p>
            <ul class="footer__social-network clearfix">
                
                
                    <li class="social-network__item">
                        <a href="https://github.com/Joe0708" target="_blank" title="Github">
                            <i class="iconfont icon-github"></i>
                        </a>
                    </li>
                
                    <li class="social-network__item">
                        <a href="https://weibo.com/5363151025/profile" target="_blank" title="WeiBo">
                            <i class="iconfont icon-weibo"></i>
                        </a>
                    </li>
                
                    <li class="social-network__item">
                        <a href="mailto:aidevjoe@gmail.com" target="_blank" title="Email">
                            <i class="iconfont icon-email"></i>
                        </a>
                    </li>
                
                    <li class="social-network__item">
                        <a href="/atom.xml" target="_blank" title="RSS">
                            <i class="iconfont icon-rss"></i>
                        </a>
                    </li>
                
                
            </ul>
        </div>
    </section>
</footer>
        

        
            
<div id="back-top" class="back-top back-top--hidden js-hidden">
    <i class="iconfont icon-top"></i>
</div>
        
    </div>

    <script src="/js/common.js"></script>

    
    <script src="/js/page/post.js"></script>


    
    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

    <script>var tags=["iOS"],gitalk=new Gitalk({clientID:"a6b73149690856adf53e",clientSecret:"2927c75214be49ec5f722b32e6724adae4cb5be4",repo:"Joe0708.github.io",owner:"Joe0708",admin:["Joe0708"],labels:tags});gitalk.render("comment-container")</script>



    

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>